{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/README.md","path":"README.md","modified":1,"renderable":0},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/about.png","path":"img/about.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/archives.png","path":"img/archives.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/blog.png","path":"img/blog.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/categories.png","path":"img/categories.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/pages.png","path":"img/pages.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/tags.png","path":"img/tags.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/wechatpay.png","path":"img/wechatpay.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/clipboard-use.js","path":"js/clipboard-use.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/debouncer.js","path":"js/debouncer.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/lazyload.js","path":"js/lazyload.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/lib/hint/hint.min.css","path":"lib/hint/hint.min.css","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"5f8b289040625c96eabd821af43aa27da4667114","modified":1596135794000},{"_id":"source/README.md","hash":"533752cd17a6993c29bb738773d74316d42a200f","modified":1596802808000},{"_id":"source/_posts/Machine-Learning.md","hash":"93ab55b1353d0826704c22b73e5d9d31fb3496e3","modified":1597614490572},{"_id":"source/_posts/git-vs-svn.md","hash":"92a69dd237b4effcf92ce0b84923a07e74e36c6d","modified":1597325147224},{"_id":"source/_posts/git.md","hash":"ec59d2201fc5a32486a1df13cb09217e5b27f898","modified":1596794876000},{"_id":"source/_posts/hello-hexo.md","hash":"b031e27a1a096f89041418f3a7804143553411cc","modified":1596794570000},{"_id":"source/_posts/svn.md","hash":"1f8d11fc621e49951c01d110f7f2f0b1916048f5","modified":1596794552000},{"_id":"source/about/index.md","hash":"63f9cdf8919532cc1f9dae90a658829c3965402f","modified":1597680290178},{"_id":"source/_posts/git-vs-svn/svn_process.jpg","hash":"493fd798637ff753142abbba1ee41b57dd3d01c3","modified":1596795404000},{"_id":"source/_posts/git-vs-svn/git_process.jpg","hash":"f624219d20d3feaab5b216ce545baa6e67efaab1","modified":1596479442000},{"_id":"source/_posts/Machine-Learning/AI.png","hash":"da07147776d8750b0e64ea4ae3f84347957ae550","modified":1597611118311},{"_id":"source/_posts/Machine-Learning/KNN.png","hash":"048595fa06908b1c3b04debca07b14582bbf7e71","modified":1597611118314},{"_id":"source/_posts/Machine-Learning/svm.png","hash":"7228d6961b13c158da9c543e7a18dbf2e04de355","modified":1597611118329},{"_id":"source/_posts/Machine-Learning/deep-learning-regression.png","hash":"c0af7b974971e2b9a4f5b3b917190619a0d48dc8","modified":1597611118315},{"_id":"source/_posts/Machine-Learning/k-means.png","hash":"24ba52333130f5ec87976ae5fd2682b2d7571f94","modified":1597611118318},{"_id":"source/_posts/Machine-Learning/linear-regression.png","hash":"4f8e983088bfa24669835b6bcf87003c856db537","modified":1597611118319},{"_id":"source/_posts/Machine-Learning/random-forest.png","hash":"5f61531ac244305616b5cc5ea2e47aed96f0cdef","modified":1597611118326},{"_id":"source/_posts/Machine-Learning/HC.png","hash":"4a67fb7b94566acea15eaf97dcac96b76c83b164","modified":1597611118313},{"_id":"source/_posts/Machine-Learning/regression-tree.png","hash":"ef1d4a108dc8224b4b959662a24a25cd4c40dc55","modified":1597611118328},{"_id":"themes/fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1596141856000},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1596141856000},{"_id":"themes/fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1596141856000},{"_id":"themes/fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1596141856000},{"_id":"themes/fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":1596141856000},{"_id":"themes/fluid/.gitignore","hash":"bd095eee271360a38772ee1a42d4f000fb722e5f","modified":1596141856000},{"_id":"themes/fluid/LICENSE","hash":"5b919c12e4f5f5cdebb7c17ded4f10f1ebe64811","modified":1596141856000},{"_id":"themes/fluid/README_en.md","hash":"99412f14c91c3bc188953eb5b347481a618facd3","modified":1596141856000},{"_id":"themes/fluid/README.md","hash":"0ff14201b4a4799d5e3b1387da8e06ead1681970","modified":1596141856000},{"_id":"themes/fluid/_config.yml","hash":"1606ef681aa8df2e969d57599d45141042087a69","modified":1596659854000},{"_id":"themes/fluid/gulpfile.js","hash":"dc82b6be72c786721a2f5e2acc10a2a94995c540","modified":1596141856000},{"_id":"themes/fluid/_static_prefix.yml","hash":"dd94756c6967838bf656735a46047bb7b0031ca1","modified":1596141856000},{"_id":"themes/fluid/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1596141856000},{"_id":"themes/fluid/package.json","hash":"d37c2637ed470ed61dd63142ab1291233267abdb","modified":1596141856000},{"_id":"themes/fluid/languages/en.yml","hash":"a85dcc5cc21f9cab50df31e5001b8818ee62d1e2","modified":1596141856000},{"_id":"themes/fluid/languages/ja.yml","hash":"91020031a847c0361a6fd7ab990c7be4bf17529b","modified":1596141856000},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"21307b4137c3d9b04bb58243747e75af0abc5a71","modified":1596141856000},{"_id":"themes/fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":1596141856000},{"_id":"themes/fluid/layout/about.ejs","hash":"e967e102bab2b35b9083165c2b8e037db8e0a32d","modified":1596141856000},{"_id":"themes/fluid/layout/archive.ejs","hash":"094357be1c2c6b477269a3f4b725d3c5dd24ef8c","modified":1596141856000},{"_id":"themes/fluid/layout/categories.ejs","hash":"3b8589675338c7b3e1849104b7bb15ac477fce4e","modified":1596141856000},{"_id":"themes/fluid/layout/category.ejs","hash":"1cfe94f46f1492a411d431b02a8d09c99cab77d5","modified":1596141856000},{"_id":"themes/fluid/layout/index.ejs","hash":"9534043275df504d70232c07fec7e10503b85d32","modified":1596141856000},{"_id":"themes/fluid/layout/layout.ejs","hash":"7450c3db44b03c1b1c859f2770f6aa77dcebd379","modified":1596141856000},{"_id":"themes/fluid/layout/links.ejs","hash":"6abd180ff4dd1d5d22e4c70328e3c7f83d174d9c","modified":1596141856000},{"_id":"themes/fluid/layout/page.ejs","hash":"8cab50ead4cdb992d35710147a9a5308fb5df290","modified":1596141856000},{"_id":"themes/fluid/layout/post.ejs","hash":"741fac94c83b2ddd6300de66314f2ef363cedb7b","modified":1596374220000},{"_id":"themes/fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1596141856000},{"_id":"themes/fluid/layout/tag.ejs","hash":"fd72ec9e6629facf63ce8122f0fa8d492669fa6a","modified":1596141856000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"867ed2bb90863934b72b7586ec7c31abf9863182","modified":1596141856000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"5c5a5565bb13928bc92332d9b99b968673ea7dfb","modified":1596141856000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"d3a3204d9bb2b43a69c9cb0be59bada8cb91e412","modified":1596141856000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"a413dc14e4737dbcaa8fb797d37f85121ede6551","modified":1596141856000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question.md","hash":"93cf5e1f1e0362adee0f63f4edcc7738cd4fc842","modified":1596141856000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":1596141856000},{"_id":"themes/fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":1596141856000},{"_id":"themes/fluid/layout/_partial/beian.ejs","hash":"4f3acc8dc822c85d0d778552a15875f71c0cd80a","modified":1596141856000},{"_id":"themes/fluid/.github/workflows/lint.yaml","hash":"628f8d7655fdba149f5a9b0232df5c3225eda9da","modified":1596141856000},{"_id":"themes/fluid/layout/_partial/css.ejs","hash":"21964c2e5c68ee3806ef80465ef5de92174cdc3a","modified":1596141856000},{"_id":"themes/fluid/layout/_partial/footer.ejs","hash":"053f7fef0f3f09c76b1d13b3dbdf2341f49630ce","modified":1596229770000},{"_id":"themes/fluid/layout/_partial/head.ejs","hash":"4359f8598a21b133d392f71772c3f9adb5de96a0","modified":1596657236000},{"_id":"themes/fluid/layout/_partial/nav.ejs","hash":"70490c67b7313ae305d39331238232fe62f094f1","modified":1596141856000},{"_id":"themes/fluid/layout/_partial/paginator.ejs","hash":"783eee847562ce14db8f723b4ae742fb69aaf620","modified":1596141856000},{"_id":"themes/fluid/layout/_partial/post-meta.ejs","hash":"afa8b2d53452609a5ee7cf32ad5f00d5a80de72e","modified":1596657660000},{"_id":"themes/fluid/layout/_partial/scripts.ejs","hash":"0d818a43079d9a2da12d9c974426d675cc0b66ea","modified":1596658124000},{"_id":"themes/fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":1596141856000},{"_id":"themes/fluid/layout/_partial/statistics.ejs","hash":"920bc618d357d48d2b96f8758f6ae8f9488fc4d8","modified":1596141856000},{"_id":"themes/fluid/layout/_partial/toc.ejs","hash":"3cf1d9b9032919d6b936e1f2410911df3b325670","modified":1596141856000},{"_id":"themes/fluid/scripts/events/index.js","hash":"36b137b75c76ff08523016dc8eac702f397d771b","modified":1596141856000},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"bb90a128a999b276c10a822c44851fa27d6d64ae","modified":1596141856000},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"f64d2121d99225e9f6d12ce646af618232f5f366","modified":1596141856000},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"6665f19fa30cbbe0853d8140a0832f8638538f89","modified":1596141856000},{"_id":"themes/fluid/scripts/utils/join-path.js","hash":"629e7deb3955f750c1cfa6fc773f412e020fcef4","modified":1596141856000},{"_id":"themes/fluid/scripts/utils/object.js","hash":"61e9555f99edcb23d55361c7154e23af33153ecb","modified":1596141856000},{"_id":"themes/fluid/scripts/tags/button.js","hash":"48e1b46b4c34b79a128dda7a0592b43be47cf955","modified":1596141856000},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"c131fb22805cec89d647e643299508487fc72576","modified":1596141856000},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1596141856000},{"_id":"themes/fluid/scripts/tags/label.js","hash":"d50f5aeb1a95adbc88cea9cca4a07165d6725408","modified":1596141856000},{"_id":"themes/fluid/scripts/tags/note.js","hash":"0886cfe3f8589671a1d289495e359c20a9908080","modified":1596141856000},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"d45dce23532c17367c7eb86b94afa8c9e40d16c6","modified":1596141856000},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"9045f47c7a71aab39f16cffb3e3847b752c2e0f1","modified":1596141856000},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"99ab4551dc9c035abcc3bf4da5def2f63449d7ec","modified":1596141856000},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"e58d422eddb44c1be893f65f79f4c7feecfe6d5f","modified":1596141856000},{"_id":"themes/fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":1596367012000},{"_id":"themes/fluid/source/img/favicon.png","hash":"eb836919d322d40dbda6aa75944d24c4da6e2e05","modified":1596276050000},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1596141856000},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1596141856000},{"_id":"themes/fluid/source/js/clipboard-use.js","hash":"f0ffe3df1deeb3cc36adfee2ab839368fb28d1c9","modified":1596141856000},{"_id":"themes/fluid/source/js/color-schema.js","hash":"6ba340eef77b2daf14c8fbb6b4f7bda9becb2526","modified":1596141856000},{"_id":"themes/fluid/source/js/debouncer.js","hash":"045f324777bdfb99d4c17b1806169f029f897a65","modified":1596141856000},{"_id":"themes/fluid/source/js/lazyload.js","hash":"792deca48c12512d3e612f0de092ffcff3ca3e34","modified":1596141856000},{"_id":"themes/fluid/source/js/local-search.js","hash":"13d5ef2fe68c49bd6096781034dbb26c190b5176","modified":1596141856000},{"_id":"themes/fluid/source/js/main.js","hash":"a6def6368d288892088f78fd401e7170e3e81a13","modified":1596141856000},{"_id":"themes/fluid/source/js/utils.js","hash":"9b06e2e2a2bb92e27d15a700f28f880317c25cfa","modified":1596141856000},{"_id":"themes/fluid/layout/_partial/comments/changyan.ejs","hash":"13c0b62854668fd83287dff3792997baeeb3a2c7","modified":1596141856000},{"_id":"themes/fluid/layout/_partial/comments/gitalk.ejs","hash":"096fef408349db4ebbec84cf20a373dd46c8f4ff","modified":1596141856000},{"_id":"themes/fluid/layout/_partial/comments/livere.ejs","hash":"f1e5d89cc98e2f6e067e5cd3db728127ccff0105","modified":1596141856000},{"_id":"themes/fluid/layout/_partial/comments/disqus.ejs","hash":"d27313450311ebadf4a92f71d269db367475c1a4","modified":1596141856000},{"_id":"themes/fluid/layout/_partial/comments/utterances.ejs","hash":"f151bc3453a67213cfdcb944c23764fb3a780722","modified":1596141856000},{"_id":"themes/fluid/layout/_partial/comments/valine.ejs","hash":"37941b3c6f66f1f22aeff734802373657dfdfb99","modified":1596141856000},{"_id":"themes/fluid/layout/_partial/plugins/analytics.ejs","hash":"0977e642c65e34d2ca2980a77b16d9ad2d3936fc","modified":1596141856000},{"_id":"themes/fluid/layout/_partial/plugins/aplayer.ejs","hash":"e843cdbe64af3dee9385eb1d763539d3ac10ed72","modified":1596141856000},{"_id":"themes/fluid/layout/_partial/plugins/anchor.ejs","hash":"3738c2ef427b4b400225b92e638a17b7ab2125ed","modified":1596141856000},{"_id":"themes/fluid/layout/_partial/plugins/leancloud.ejs","hash":"7807e58722dcf992fba11bc879b0fac0e904dc76","modified":1596141856000},{"_id":"themes/fluid/layout/_partial/plugins/local-search.ejs","hash":"03b024c7bab51b64e5187c9dbfac039d020f1e97","modified":1596141856000},{"_id":"themes/fluid/layout/_partial/plugins/daovoice.ejs","hash":"cfc684ba48608abd25afd155ee373d9936bbe84e","modified":1596141856000},{"_id":"themes/fluid/layout/_partial/plugins/fancybox.ejs","hash":"c447e35c93c61a70c1c2dfc34948615832989660","modified":1596141856000},{"_id":"themes/fluid/layout/_partial/plugins/math.ejs","hash":"76c4e0608ae362a265ac5e9c0fc49f75c1bc568e","modified":1596141856000},{"_id":"themes/fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":1596141856000},{"_id":"themes/fluid/layout/_partial/plugins/mouse-click.ejs","hash":"eb19991199c201ceb103a6ef025e4dfd1e7dbfb7","modified":1596141856000},{"_id":"themes/fluid/layout/_partial/plugins/tocjs.ejs","hash":"2d35295dba2bb912d6ce2ec7747af06bfdc82edb","modified":1596141856000},{"_id":"themes/fluid/layout/_partial/plugins/typed.ejs","hash":"38334350425008d1f64323de221457ee0948af0e","modified":1596141856000},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"3b2abc5f5e3b681874637e98e047dc4969eb1983","modified":1596141856000},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"da4c281a8b2d2ed813da1236950c9dff87334adc","modified":1596141856000},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"4adf895fa1157aaf5a194f8b760332b6215656ef","modified":1596141856000},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"374583fd419ac6477dfca69e09756db543d7ec80","modified":1596141856000},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"ee7dfef805af96195c11223cca53983deace8bda","modified":1596141856000},{"_id":"themes/fluid/scripts/events/lib/version.js","hash":"5fed24e25662a1b08fd857fde2d770fdc6250475","modified":1596141856000},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1596141856000},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1596141856000},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1596374220000},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"1678c5bbb1aa2e17681f8e88776ecb802bc85b69","modified":1596141856000},{"_id":"themes/fluid/source/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1596141856000},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"aa2528e71c290dc43b69dfbdcf4d8d6c258015a4","modified":1596141856000},{"_id":"themes/fluid/source/css/_pages/_base/color-schema.styl","hash":"7231920523d634670344a452908f933b29a452be","modified":1596141856000},{"_id":"themes/fluid/source/css/_pages/_base/inline.styl","hash":"fab8441a0b8d8f9db6c8370013659c035345ae79","modified":1596141856000},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1596141856000},{"_id":"themes/fluid/source/css/_pages/_base/rewrite.styl","hash":"439fce1b41bc1134399e7f2ce6ffe5aa64568acd","modified":1596141856000},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"7e07e44fa0e77ddbdd3aa0c0abdb3be6822df2e0","modified":1596141856000},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":1596141856000},{"_id":"themes/fluid/source/css/_pages/_category/categories.styl","hash":"1ab7db37c2f7dc7ccdb994dcb41c16a4c8920397","modified":1596141856000},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"cd4ebb1426abed9fda93b797b02c6d5dd71dc2a1","modified":1596141856000},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"c443551deb389102e65cbb2441f60e8c20712ee8","modified":1596141856000},{"_id":"themes/fluid/source/css/_pages/_post/post.styl","hash":"9b1e89033007f2bb0ec6c3eabb2e94be69a5f78a","modified":1596371602000},{"_id":"themes/fluid/source/css/_pages/_post/tag_plugin.styl","hash":"cbb49a17fcc030029f0c2fbe1e056613109d1ecc","modified":1596141856000},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1596141856000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/banner.styl","hash":"5f8738c43539c27ad2ce7635a53b2cac522f1c13","modified":1596141856000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"2c9e05a354d4be820646a1c99f814740f299ed37","modified":1596141856000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/board.styl","hash":"32d90bcc8bf2fd5d8d78e86a567973d4b69bcfa1","modified":1596141856000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footer.styl","hash":"6b8340a41afc6b6e5f30dc9e912a0e0265446963","modified":1596141856000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1596141856000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/header.styl","hash":"7c8170d0e2de47570fe8ed523f10ee1c33138a9f","modified":1596141856000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"fe74d031acef4403e1510d4cce5bc7accd641780","modified":1596141856000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f1cd98a5b8d98535d707a99dba6a00f1f3978c81","modified":1596141856000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1596141856000},{"_id":"source/_posts/Machine-Learning/logistic-regression.png","hash":"12842d3ba19a26ee7adec6570f22057519423c61","modified":1597611118322},{"_id":"themes/fluid/source/img/wechatpay.png","hash":"b3d18f4e01322c23fdd764e6d8b3136c4d75e69e","modified":1596289572000},{"_id":"themes/fluid/source/img/avatar.png","hash":"443916f17da21def6f92e4e2b0bbcbf5f6802dfa","modified":1596198644000},{"_id":"themes/fluid/source/img/archives.png","hash":"6c1a9bf65b004c36a5478a9882735a0054725baf","modified":1596200300000},{"_id":"themes/fluid/source/img/categories.png","hash":"d4289187f8270e398e0f55813c4e2213496719bc","modified":1596224894000},{"_id":"themes/fluid/source/img/blog.png","hash":"e75dfb1af5785e6fadcca76ebc27570457726450","modified":1596801480000},{"_id":"themes/fluid/source/img/pages.png","hash":"3d8d3077daa43866c081d02ff28a3e628d225326","modified":1596224990000},{"_id":"themes/fluid/source/img/tags.png","hash":"dc7e42f0706e4a86a430e9bca25f31520e9d40f6","modified":1596225028000},{"_id":"themes/fluid/source/img/about.png","hash":"3d41f3b65a462467f2fb96f5acb8e962be106171","modified":1596225588000},{"_id":"themes/fluid/source/img/default.png","hash":"ea5794ea60c56ab21031543fb055bccf1b01a21d","modified":1596224364000},{"_id":"public/atom.xml","hash":"5eb31d4d2f7d8eda083a99adfd2d1902434303fb","modified":1597680897882},{"_id":"public/search.xml","hash":"d03b8a1bddb87e72315ee3c713fef82bb4ec51e1","modified":1597680897882},{"_id":"public/sitemap.xml","hash":"9052ca46d2d477825a3d5f3ab23d3170f78a57c6","modified":1597680897882},{"_id":"public/local-search.xml","hash":"d6c79a30ee18e94f7e546c35a6da1faacb1738df","modified":1597680897882},{"_id":"public/about/index.html","hash":"80fea4603bb0a62f3bf4c7a82e097fc1b3817f0c","modified":1597680897882},{"_id":"public/2020/07/29/hello-hexo/index.html","hash":"ba303d4f57062d8c193b43188998f777ba86865c","modified":1597680897882},{"_id":"public/categories/版本控制（git-svn）/index.html","hash":"fd9adb5146fbea599434f6002b2920078b0cdbf9","modified":1597680897882},{"_id":"public/categories/hexo/index.html","hash":"8f8d498478953bceeaf3afeb0258120dc7352db3","modified":1597680897882},{"_id":"public/archives/index.html","hash":"baaff9d45db38117f4b503843ae8442d0ba995ad","modified":1597680897882},{"_id":"public/categories/机器学习（machine-learning）/index.html","hash":"fbda9aa16187ba6d9aeee0e6a1f77666a6a1f8fc","modified":1597680897882},{"_id":"public/archives/2020/index.html","hash":"baaff9d45db38117f4b503843ae8442d0ba995ad","modified":1597680897882},{"_id":"public/archives/2020/07/index.html","hash":"0d8367ac56537c0ef66b054e7c44febbdd5fc0d4","modified":1597680897882},{"_id":"public/archives/2020/08/index.html","hash":"20d278bbf8a07f959a2ce44d78a297164ec4f246","modified":1597680897882},{"_id":"public/index.html","hash":"712842f387200f158f1cb85532eb7bd8989cc5aa","modified":1597680897882},{"_id":"public/tags/git/index.html","hash":"f356ab3165474f139e2f18b9208d7b1fdc917942","modified":1597680897882},{"_id":"public/tags/svn/index.html","hash":"84db15c2db84d64fbc766614b1bac475a0c25bb6","modified":1597680897882},{"_id":"public/tags/introduction/index.html","hash":"e52ec4395b9731b60330acbd4ec8d986dc542530","modified":1597680897882},{"_id":"public/tags/tutorial/index.html","hash":"441887612e241f5ef6b700fd01b168909cd0aa2f","modified":1597680897882},{"_id":"public/404.html","hash":"c0ebf6da6791c2005893edbd4e4d814334527e60","modified":1597680897882},{"_id":"public/tags/machine-Learning/index.html","hash":"860e14d255faee3c3d522f2c50e5a2ef495384c4","modified":1597680897882},{"_id":"public/tags/index.html","hash":"b63e19997e04244e6bbf4843355ec6b6b876a9db","modified":1597680897882},{"_id":"public/categories/index.html","hash":"7293ad20f5031c954d9a7b6d2c4872bbe2a25498","modified":1597680897882},{"_id":"public/2020/08/13/Machine-Learning/index.html","hash":"eef79cea5ac8d432ed8ef20927f7ed608bcda974","modified":1597680897882},{"_id":"public/2020/08/03/svn/index.html","hash":"20c8fe8097d6a2587f23a9888d37cdd9180daac3","modified":1597680897882},{"_id":"public/2020/08/02/git/index.html","hash":"cd744d86aecb686dcc0ae4cf8eda1173b58bc705","modified":1597680897882},{"_id":"public/2020/08/01/git-vs-svn/index.html","hash":"ea3f44cccec4c541c5a111966ed576cba62cf8c7","modified":1597680897882},{"_id":"public/links/index.html","hash":"cb7a3fd1a119e1ca06d506141d5953d0670ca1bd","modified":1597680897882},{"_id":"public/CNAME","hash":"5f8b289040625c96eabd821af43aa27da4667114","modified":1597680897882},{"_id":"public/README.md","hash":"533752cd17a6993c29bb738773d74316d42a200f","modified":1597680897882},{"_id":"public/img/favicon.png","hash":"eb836919d322d40dbda6aa75944d24c4da6e2e05","modified":1597680897882},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1597680897882},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1597680897882},{"_id":"public/2020/08/01/git-vs-svn/svn_process.jpg","hash":"493fd798637ff753142abbba1ee41b57dd3d01c3","modified":1597680897882},{"_id":"public/2020/08/01/git-vs-svn/git_process.jpg","hash":"f624219d20d3feaab5b216ce545baa6e67efaab1","modified":1597680897882},{"_id":"public/2020/08/13/Machine-Learning/AI.png","hash":"da07147776d8750b0e64ea4ae3f84347957ae550","modified":1597680897882},{"_id":"public/2020/08/13/Machine-Learning/KNN.png","hash":"048595fa06908b1c3b04debca07b14582bbf7e71","modified":1597680897882},{"_id":"public/2020/08/13/Machine-Learning/svm.png","hash":"7228d6961b13c158da9c543e7a18dbf2e04de355","modified":1597680897882},{"_id":"public/2020/08/13/Machine-Learning/deep-learning-regression.png","hash":"c0af7b974971e2b9a4f5b3b917190619a0d48dc8","modified":1597680897882},{"_id":"public/2020/08/13/Machine-Learning/k-means.png","hash":"24ba52333130f5ec87976ae5fd2682b2d7571f94","modified":1597680897882},{"_id":"public/2020/08/13/Machine-Learning/linear-regression.png","hash":"4f8e983088bfa24669835b6bcf87003c856db537","modified":1597680897882},{"_id":"public/2020/08/13/Machine-Learning/random-forest.png","hash":"5f61531ac244305616b5cc5ea2e47aed96f0cdef","modified":1597680897882},{"_id":"public/css/main.css","hash":"c6d9d60b37d83b059185c6db7d832bc5bc0c31af","modified":1597680897882},{"_id":"public/img/wechatpay.png","hash":"b3d18f4e01322c23fdd764e6d8b3136c4d75e69e","modified":1597680897882},{"_id":"public/2020/08/13/Machine-Learning/HC.png","hash":"4a67fb7b94566acea15eaf97dcac96b76c83b164","modified":1597680897882},{"_id":"public/2020/08/13/Machine-Learning/regression-tree.png","hash":"ef1d4a108dc8224b4b959662a24a25cd4c40dc55","modified":1597680897882},{"_id":"public/js/clipboard-use.js","hash":"f0ffe3df1deeb3cc36adfee2ab839368fb28d1c9","modified":1597680897882},{"_id":"public/js/lazyload.js","hash":"792deca48c12512d3e612f0de092ffcff3ca3e34","modified":1597680897882},{"_id":"public/js/color-schema.js","hash":"6ba340eef77b2daf14c8fbb6b4f7bda9becb2526","modified":1597680897882},{"_id":"public/js/debouncer.js","hash":"045f324777bdfb99d4c17b1806169f029f897a65","modified":1597680897882},{"_id":"public/js/local-search.js","hash":"13d5ef2fe68c49bd6096781034dbb26c190b5176","modified":1597680897882},{"_id":"public/js/utils.js","hash":"9b06e2e2a2bb92e27d15a700f28f880317c25cfa","modified":1597680897882},{"_id":"public/js/main.js","hash":"a6def6368d288892088f78fd401e7170e3e81a13","modified":1597680897882},{"_id":"public/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1597680897882},{"_id":"public/2020/08/13/Machine-Learning/logistic-regression.png","hash":"12842d3ba19a26ee7adec6570f22057519423c61","modified":1597680897882},{"_id":"public/img/avatar.png","hash":"443916f17da21def6f92e4e2b0bbcbf5f6802dfa","modified":1597680897882},{"_id":"public/img/archives.png","hash":"6c1a9bf65b004c36a5478a9882735a0054725baf","modified":1597680897882},{"_id":"public/img/categories.png","hash":"d4289187f8270e398e0f55813c4e2213496719bc","modified":1597680897882},{"_id":"public/img/blog.png","hash":"e75dfb1af5785e6fadcca76ebc27570457726450","modified":1597680897882},{"_id":"public/img/pages.png","hash":"3d8d3077daa43866c081d02ff28a3e628d225326","modified":1597680897882},{"_id":"public/img/tags.png","hash":"dc7e42f0706e4a86a430e9bca25f31520e9d40f6","modified":1597680897882},{"_id":"public/img/about.png","hash":"3d41f3b65a462467f2fb96f5acb8e962be106171","modified":1597680897882},{"_id":"public/img/default.png","hash":"ea5794ea60c56ab21031543fb055bccf1b01a21d","modified":1597680897882}],"Category":[{"name":"版本控制（git svn）","_id":"ckdypyf6x0003m4k27okw1nz0"},{"name":"hexo","_id":"ckdypyf72000fm4k247ju0a1r"},{"name":"机器学习（machine learning）","_id":"ckdypyf74000jm4k25rwnaa7o"}],"Data":[],"Page":[{"title":"about","date":"2020-07-31T21:23:08.000Z","layout":"about","_content":"\n## Hi\nWith this blog I would like to share with you something useful that I have learned.\n\n## 我\n曾经就读于同济大学和德国斯图加特大学，现在是一名自动驾驶软件开发工程师。\n热衷尝试新鲜事物，不喜欢“安分守己”，喜欢锻炼自己，挑战自己。\n\n创建这个博客主要有三个原因：\n- 想把自己平时在网上找到的有用的资源整理和记录下来，并分享给大家。\n- 利用空闲时间做点有意义的事。\n- 好玩儿2333。\n\n##  \n> 你不够成功，因为你不够孤独。\n> Without great solitude no serious work is possible.\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2020-07-31 23:23:08\nlayout: about\n---\n\n## Hi\nWith this blog I would like to share with you something useful that I have learned.\n\n## 我\n曾经就读于同济大学和德国斯图加特大学，现在是一名自动驾驶软件开发工程师。\n热衷尝试新鲜事物，不喜欢“安分守己”，喜欢锻炼自己，挑战自己。\n\n创建这个博客主要有三个原因：\n- 想把自己平时在网上找到的有用的资源整理和记录下来，并分享给大家。\n- 利用空闲时间做点有意义的事。\n- 好玩儿2333。\n\n##  \n> 你不够成功，因为你不够孤独。\n> Without great solitude no serious work is possible.\n","updated":"2020-08-17T16:04:50.178Z","path":"about/index.html","comments":1,"_id":"ckdypyf6r0000m4k20q6d3gma","content":"<h2 id=\"Hi\"><a href=\"#Hi\" class=\"headerlink\" title=\"Hi\"></a>Hi</h2><p>With this blog I would like to share with you something useful that I have learned.</p>\n<h2 id=\"我\"><a href=\"#我\" class=\"headerlink\" title=\"我\"></a>我</h2><p>曾经就读于同济大学和德国斯图加特大学，现在是一名自动驾驶软件开发工程师。<br>热衷尝试新鲜事物，不喜欢“安分守己”，喜欢锻炼自己，挑战自己。</p>\n<p>创建这个博客主要有三个原因：</p>\n<ul>\n<li>想把自己平时在网上找到的有用的资源整理和记录下来，并分享给大家。</li>\n<li>利用空闲时间做点有意义的事。</li>\n<li>好玩儿2333。</li>\n</ul>\n<h2 id><a href=\"#\" class=\"headerlink\" title=\" \"></a> </h2><blockquote>\n<p>你不够成功，因为你不够孤独。<br>Without great solitude no serious work is possible.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Hi\"><a href=\"#Hi\" class=\"headerlink\" title=\"Hi\"></a>Hi</h2><p>With this blog I would like to share with you something useful that I have learned.</p>\n<h2 id=\"我\"><a href=\"#我\" class=\"headerlink\" title=\"我\"></a>我</h2><p>曾经就读于同济大学和德国斯图加特大学，现在是一名自动驾驶软件开发工程师。<br>热衷尝试新鲜事物，不喜欢“安分守己”，喜欢锻炼自己，挑战自己。</p>\n<p>创建这个博客主要有三个原因：</p>\n<ul>\n<li>想把自己平时在网上找到的有用的资源整理和记录下来，并分享给大家。</li>\n<li>利用空闲时间做点有意义的事。</li>\n<li>好玩儿2333。</li>\n</ul>\n<h2 id><a href=\"#\" class=\"headerlink\" title=\" \"></a> </h2><blockquote>\n<p>你不够成功，因为你不够孤独。<br>Without great solitude no serious work is possible.</p>\n</blockquote>\n"}],"Post":[{"title":"git vs. svn","date":"2020-08-01T21:55:36.000Z","_content":"\n本文主要介绍git和svn的区别与作用。\n\n<!-- more -->\n\n## GIT\n\ngit是一个应用最广泛的免费的、开源的分布式版本控制系统，github是最常用的提供远程git仓库托管服务的网站。git与常用的集中式版本控制工具Subversion(svn)不同，它采用了分布式版本库的方法，不依赖服务器端软件支持，其最大特点在于开发者可以提交到本地，每个开发者通过克隆（git clone），在本地拷贝一个完整的git仓库。\n\n**工作流程：**\n\n下图是经典的git开发过程。\n![git process](git-vs-svn/git_process.jpg)\n\n**功能特性：**\n\n从一般开发者的角度来看，git有以下功能：\n\n　1．从服务器上克隆完整的Git仓库（包括代码和版本信息）到单机上。\n　2．在自己的机器上根据不同的开发目的，创建分支，修改代码。\n　3．在单机上自己创建的分支上提交代码。\n　4．在单机上合并分支。\n　5．把服务器上最新版的代码fetch下来，然后跟自己的主分支合并。\n　6．生成补丁（patch），把补丁发送给主开发者。\n　7．看主开发者的反馈，如果主开发者发现两个一般开发者之间有冲突（他们之间可以合作解决的冲突），就会要求他们先解决冲突，然后再由其中一个人提交。如果主开发者可以自己解决，或者没有冲突，就通过。\n　8．一般开发者之间解决冲突的方法，开发者之间可以使用pull 命令解决冲突，解决完冲突之后再向主开发者提交补丁。\n  \n从主开发者的角度看（假设主开发者不用开发代码），git有以下功能：\n\n　1．查看邮件或者通过其它方式查看一般开发者的提交状态。\n　2．打上补丁，解决冲突（可以自己解决，也可以要求开发者之间解决以后再重新提交，如果是开源项目，还要决定哪些补丁有用，哪些不用）。\n　3．向公共服务器提交结果，然后通知所有开发人员。 \n\n## SVN\n\nSVN是Subversion的简称，是一个开源的版本控制系统，支持大多数常见的操作系统。作为一个开源的版本控制系统，Subversion管理着随时间改变的数据，这些数据放置在一个中央资料档案库（repository）中，这个档案库很像一个普通的文件服务器,不过它会记住每一次文件的变动，这样你就可以把档案恢复到旧的版本，或是浏览文件的变动历史。Subversion是一个通用的系统,可用来管理任何类型的文件，其中包括程序源码。\n\n**工作流程：**\n\n集中式管理的工作流程如下图：\n![svn process](git-vs-svn/svn_process.jpg)\n\n集中式代码管理的核心是服务器，所有开发者在开始新一天的工作之前必须从服务器获取代码，然后开发，最后解决冲突，提交。所有的版本信息都放在服务器上。如果脱离了服务器，开发者基本上可以说是无法工作的。\n\n**功能特性：**\n\n　1．从服务器下载项目组最新代码。\n　2．进入自己的分支，进行工作，每隔一个小时向服务器自己的分支提交一次代码（很多人都有这个习惯，因为有时候自己对代码改来改去，最后又想还原到前一个小时的版本，或者看看前一个小时自己修改了哪些代码，就需要这样做了）。\n　3．下班时间快到了，把自己的分支合并到服务器主分支上，一天的工作完成，并反映给服务器。\n\n## 区别\n\n1. 适用对象不同。Git适用于参与开源项目的开发者，他们由于水平高，更在乎的是效率而不是易用性。SVN则不同，它适合普通的公司开发团队，使用起来更加容易。\n\n2. 使用的场合不同。Git适用于通过Internet，有多个开发角色的单个项目开发。SVN适合企业内部由项目经理统一协调的多个并行项目的开发。\n\n3. 权限管理策略不同。Git没有严格的权限管理控制，只要有帐号，就可以导出、导入代码，甚至执行回退操作。SVN则有严格的权限管理，可以按组、按个人进行针对某个子目录的权限控制，区分读、写权限。更严格的，不支持回退操作，保证代码永远可以追踪。\n\n4. 分支（branch）的使用范围不同。Git中，你只能针对整个仓库作branch，而且一旦删除，便无法恢复。而SVN中，branch可以针对任何子目录，它本质上是一个拷贝操作，所以，可以建立非常多、层次性的branch，并且，在不需要时将其删除，而以后需要时只要checkout老的SVN版本就可以了。\n\n5. 基于第三点，Git适用于单纯的软件项目，典型的就是一些开源项目，比如Linux内核、busybox等。相反，SVN擅长多项目管理。比如，你可以在一个SVN仓库中存放一个手机项目的bsp/设计文档/文件系统/应用程序/自动化编译脚本，或者在一个SVN中存放5款手机项目的文件系统。git中必须建立n（项目数）* m（组件数）个仓库。SVN中只需要最多n或者m个就可以了。\n\n6. Git使用128位ID作为版本号，而且checkout时要注明是哪个branch，而SVN使用一个递增的序列号作为全局唯一的版本号，更加简明易懂。虽然可以使用gittag来建立一些文字化的别名，但是毕竟那只是针对特殊版本。\n\n7. 可跟踪性，git的典型开发过程为：建立分支，进行开发，提交到本地master，删除分支。这样做的后果是以前的修改细节会丢失。而在SVN下做同样的事情，不会丢失任何细节。这里是一个有趣的链接，表明了git下典型的工作方式：（以master为核心，不断创建新branch，删除旧branch)。\n\n8. 局部更新，局部还原。SVN由于是在每个文件夹建立一个.svn文件夹来实现管理，所以可以很简单实现局部更新或者还原。假如你只希望更新某些部分，则svn可以很好实现。同时代码写错了，同时可以很好实现局部还原，当然git也可以通过历史版本还原，但是无法简单地实现局部还原。\n\n## 总结\n\n公司的开发团队在进行项目开发管理时，svn是更好的选择，团队成员共同维护公司的中心版本。若是开源项目，则git更加适合，每个人都可以维护自己专属的版本，同时有github开源社区支持。\n\n---\n\n## 参考\n\n1. [github官网](https://docs.github.com/en/github)\n2. [百度百科-git](https://baike.baidu.com/item/GIT/12647237#3)\n3. [SVN和GIT介绍，区别，使用](https://blog.csdn.net/mine_song/article/details/70770467)\n","source":"_posts/git-vs-svn.md","raw":"---\ntitle: git vs. svn\ndate: 2020-08-01 23:55:36\ntags:\n- git\n- svn\n- introduction\ncategories:\n- [版本控制（git svn）]\n---\n\n本文主要介绍git和svn的区别与作用。\n\n<!-- more -->\n\n## GIT\n\ngit是一个应用最广泛的免费的、开源的分布式版本控制系统，github是最常用的提供远程git仓库托管服务的网站。git与常用的集中式版本控制工具Subversion(svn)不同，它采用了分布式版本库的方法，不依赖服务器端软件支持，其最大特点在于开发者可以提交到本地，每个开发者通过克隆（git clone），在本地拷贝一个完整的git仓库。\n\n**工作流程：**\n\n下图是经典的git开发过程。\n![git process](git-vs-svn/git_process.jpg)\n\n**功能特性：**\n\n从一般开发者的角度来看，git有以下功能：\n\n　1．从服务器上克隆完整的Git仓库（包括代码和版本信息）到单机上。\n　2．在自己的机器上根据不同的开发目的，创建分支，修改代码。\n　3．在单机上自己创建的分支上提交代码。\n　4．在单机上合并分支。\n　5．把服务器上最新版的代码fetch下来，然后跟自己的主分支合并。\n　6．生成补丁（patch），把补丁发送给主开发者。\n　7．看主开发者的反馈，如果主开发者发现两个一般开发者之间有冲突（他们之间可以合作解决的冲突），就会要求他们先解决冲突，然后再由其中一个人提交。如果主开发者可以自己解决，或者没有冲突，就通过。\n　8．一般开发者之间解决冲突的方法，开发者之间可以使用pull 命令解决冲突，解决完冲突之后再向主开发者提交补丁。\n  \n从主开发者的角度看（假设主开发者不用开发代码），git有以下功能：\n\n　1．查看邮件或者通过其它方式查看一般开发者的提交状态。\n　2．打上补丁，解决冲突（可以自己解决，也可以要求开发者之间解决以后再重新提交，如果是开源项目，还要决定哪些补丁有用，哪些不用）。\n　3．向公共服务器提交结果，然后通知所有开发人员。 \n\n## SVN\n\nSVN是Subversion的简称，是一个开源的版本控制系统，支持大多数常见的操作系统。作为一个开源的版本控制系统，Subversion管理着随时间改变的数据，这些数据放置在一个中央资料档案库（repository）中，这个档案库很像一个普通的文件服务器,不过它会记住每一次文件的变动，这样你就可以把档案恢复到旧的版本，或是浏览文件的变动历史。Subversion是一个通用的系统,可用来管理任何类型的文件，其中包括程序源码。\n\n**工作流程：**\n\n集中式管理的工作流程如下图：\n![svn process](git-vs-svn/svn_process.jpg)\n\n集中式代码管理的核心是服务器，所有开发者在开始新一天的工作之前必须从服务器获取代码，然后开发，最后解决冲突，提交。所有的版本信息都放在服务器上。如果脱离了服务器，开发者基本上可以说是无法工作的。\n\n**功能特性：**\n\n　1．从服务器下载项目组最新代码。\n　2．进入自己的分支，进行工作，每隔一个小时向服务器自己的分支提交一次代码（很多人都有这个习惯，因为有时候自己对代码改来改去，最后又想还原到前一个小时的版本，或者看看前一个小时自己修改了哪些代码，就需要这样做了）。\n　3．下班时间快到了，把自己的分支合并到服务器主分支上，一天的工作完成，并反映给服务器。\n\n## 区别\n\n1. 适用对象不同。Git适用于参与开源项目的开发者，他们由于水平高，更在乎的是效率而不是易用性。SVN则不同，它适合普通的公司开发团队，使用起来更加容易。\n\n2. 使用的场合不同。Git适用于通过Internet，有多个开发角色的单个项目开发。SVN适合企业内部由项目经理统一协调的多个并行项目的开发。\n\n3. 权限管理策略不同。Git没有严格的权限管理控制，只要有帐号，就可以导出、导入代码，甚至执行回退操作。SVN则有严格的权限管理，可以按组、按个人进行针对某个子目录的权限控制，区分读、写权限。更严格的，不支持回退操作，保证代码永远可以追踪。\n\n4. 分支（branch）的使用范围不同。Git中，你只能针对整个仓库作branch，而且一旦删除，便无法恢复。而SVN中，branch可以针对任何子目录，它本质上是一个拷贝操作，所以，可以建立非常多、层次性的branch，并且，在不需要时将其删除，而以后需要时只要checkout老的SVN版本就可以了。\n\n5. 基于第三点，Git适用于单纯的软件项目，典型的就是一些开源项目，比如Linux内核、busybox等。相反，SVN擅长多项目管理。比如，你可以在一个SVN仓库中存放一个手机项目的bsp/设计文档/文件系统/应用程序/自动化编译脚本，或者在一个SVN中存放5款手机项目的文件系统。git中必须建立n（项目数）* m（组件数）个仓库。SVN中只需要最多n或者m个就可以了。\n\n6. Git使用128位ID作为版本号，而且checkout时要注明是哪个branch，而SVN使用一个递增的序列号作为全局唯一的版本号，更加简明易懂。虽然可以使用gittag来建立一些文字化的别名，但是毕竟那只是针对特殊版本。\n\n7. 可跟踪性，git的典型开发过程为：建立分支，进行开发，提交到本地master，删除分支。这样做的后果是以前的修改细节会丢失。而在SVN下做同样的事情，不会丢失任何细节。这里是一个有趣的链接，表明了git下典型的工作方式：（以master为核心，不断创建新branch，删除旧branch)。\n\n8. 局部更新，局部还原。SVN由于是在每个文件夹建立一个.svn文件夹来实现管理，所以可以很简单实现局部更新或者还原。假如你只希望更新某些部分，则svn可以很好实现。同时代码写错了，同时可以很好实现局部还原，当然git也可以通过历史版本还原，但是无法简单地实现局部还原。\n\n## 总结\n\n公司的开发团队在进行项目开发管理时，svn是更好的选择，团队成员共同维护公司的中心版本。若是开源项目，则git更加适合，每个人都可以维护自己专属的版本，同时有github开源社区支持。\n\n---\n\n## 参考\n\n1. [github官网](https://docs.github.com/en/github)\n2. [百度百科-git](https://baike.baidu.com/item/GIT/12647237#3)\n3. [SVN和GIT介绍，区别，使用](https://blog.csdn.net/mine_song/article/details/70770467)\n","slug":"git-vs-svn","published":1,"updated":"2020-08-13T13:25:47.224Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdypyf6t0001m4k23iqy0ytj","content":"<p>本文主要介绍git和svn的区别与作用。</p>\n<a id=\"more\"></a>\n<h2 id=\"GIT\"><a href=\"#GIT\" class=\"headerlink\" title=\"GIT\"></a>GIT</h2><p>git是一个应用最广泛的免费的、开源的分布式版本控制系统，github是最常用的提供远程git仓库托管服务的网站。git与常用的集中式版本控制工具Subversion(svn)不同，它采用了分布式版本库的方法，不依赖服务器端软件支持，其最大特点在于开发者可以提交到本地，每个开发者通过克隆（git clone），在本地拷贝一个完整的git仓库。</p>\n<p><strong>工作流程：</strong></p>\n<p>下图是经典的git开发过程。<br><img src=\"/2020/08/01/git-vs-svn/git_process.jpg\" alt=\"git process\"></p>\n<p><strong>功能特性：</strong></p>\n<p>从一般开发者的角度来看，git有以下功能：</p>\n<p>　1．从服务器上克隆完整的Git仓库（包括代码和版本信息）到单机上。<br>　2．在自己的机器上根据不同的开发目的，创建分支，修改代码。<br>　3．在单机上自己创建的分支上提交代码。<br>　4．在单机上合并分支。<br>　5．把服务器上最新版的代码fetch下来，然后跟自己的主分支合并。<br>　6．生成补丁（patch），把补丁发送给主开发者。<br>　7．看主开发者的反馈，如果主开发者发现两个一般开发者之间有冲突（他们之间可以合作解决的冲突），就会要求他们先解决冲突，然后再由其中一个人提交。如果主开发者可以自己解决，或者没有冲突，就通过。<br>　8．一般开发者之间解决冲突的方法，开发者之间可以使用pull 命令解决冲突，解决完冲突之后再向主开发者提交补丁。</p>\n<p>从主开发者的角度看（假设主开发者不用开发代码），git有以下功能：</p>\n<p>　1．查看邮件或者通过其它方式查看一般开发者的提交状态。<br>　2．打上补丁，解决冲突（可以自己解决，也可以要求开发者之间解决以后再重新提交，如果是开源项目，还要决定哪些补丁有用，哪些不用）。<br>　3．向公共服务器提交结果，然后通知所有开发人员。 </p>\n<h2 id=\"SVN\"><a href=\"#SVN\" class=\"headerlink\" title=\"SVN\"></a>SVN</h2><p>SVN是Subversion的简称，是一个开源的版本控制系统，支持大多数常见的操作系统。作为一个开源的版本控制系统，Subversion管理着随时间改变的数据，这些数据放置在一个中央资料档案库（repository）中，这个档案库很像一个普通的文件服务器,不过它会记住每一次文件的变动，这样你就可以把档案恢复到旧的版本，或是浏览文件的变动历史。Subversion是一个通用的系统,可用来管理任何类型的文件，其中包括程序源码。</p>\n<p><strong>工作流程：</strong></p>\n<p>集中式管理的工作流程如下图：<br><img src=\"/2020/08/01/git-vs-svn/svn_process.jpg\" alt=\"svn process\"></p>\n<p>集中式代码管理的核心是服务器，所有开发者在开始新一天的工作之前必须从服务器获取代码，然后开发，最后解决冲突，提交。所有的版本信息都放在服务器上。如果脱离了服务器，开发者基本上可以说是无法工作的。</p>\n<p><strong>功能特性：</strong></p>\n<p>　1．从服务器下载项目组最新代码。<br>　2．进入自己的分支，进行工作，每隔一个小时向服务器自己的分支提交一次代码（很多人都有这个习惯，因为有时候自己对代码改来改去，最后又想还原到前一个小时的版本，或者看看前一个小时自己修改了哪些代码，就需要这样做了）。<br>　3．下班时间快到了，把自己的分支合并到服务器主分支上，一天的工作完成，并反映给服务器。</p>\n<h2 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h2><ol>\n<li><p>适用对象不同。Git适用于参与开源项目的开发者，他们由于水平高，更在乎的是效率而不是易用性。SVN则不同，它适合普通的公司开发团队，使用起来更加容易。</p>\n</li>\n<li><p>使用的场合不同。Git适用于通过Internet，有多个开发角色的单个项目开发。SVN适合企业内部由项目经理统一协调的多个并行项目的开发。</p>\n</li>\n<li><p>权限管理策略不同。Git没有严格的权限管理控制，只要有帐号，就可以导出、导入代码，甚至执行回退操作。SVN则有严格的权限管理，可以按组、按个人进行针对某个子目录的权限控制，区分读、写权限。更严格的，不支持回退操作，保证代码永远可以追踪。</p>\n</li>\n<li><p>分支（branch）的使用范围不同。Git中，你只能针对整个仓库作branch，而且一旦删除，便无法恢复。而SVN中，branch可以针对任何子目录，它本质上是一个拷贝操作，所以，可以建立非常多、层次性的branch，并且，在不需要时将其删除，而以后需要时只要checkout老的SVN版本就可以了。</p>\n</li>\n<li><p>基于第三点，Git适用于单纯的软件项目，典型的就是一些开源项目，比如Linux内核、busybox等。相反，SVN擅长多项目管理。比如，你可以在一个SVN仓库中存放一个手机项目的bsp/设计文档/文件系统/应用程序/自动化编译脚本，或者在一个SVN中存放5款手机项目的文件系统。git中必须建立n（项目数）* m（组件数）个仓库。SVN中只需要最多n或者m个就可以了。</p>\n</li>\n<li><p>Git使用128位ID作为版本号，而且checkout时要注明是哪个branch，而SVN使用一个递增的序列号作为全局唯一的版本号，更加简明易懂。虽然可以使用gittag来建立一些文字化的别名，但是毕竟那只是针对特殊版本。</p>\n</li>\n<li><p>可跟踪性，git的典型开发过程为：建立分支，进行开发，提交到本地master，删除分支。这样做的后果是以前的修改细节会丢失。而在SVN下做同样的事情，不会丢失任何细节。这里是一个有趣的链接，表明了git下典型的工作方式：（以master为核心，不断创建新branch，删除旧branch)。</p>\n</li>\n<li><p>局部更新，局部还原。SVN由于是在每个文件夹建立一个.svn文件夹来实现管理，所以可以很简单实现局部更新或者还原。假如你只希望更新某些部分，则svn可以很好实现。同时代码写错了，同时可以很好实现局部还原，当然git也可以通过历史版本还原，但是无法简单地实现局部还原。</p>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>公司的开发团队在进行项目开发管理时，svn是更好的选择，团队成员共同维护公司的中心版本。若是开源项目，则git更加适合，每个人都可以维护自己专属的版本，同时有github开源社区支持。</p>\n<hr>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://docs.github.com/en/github\">github官网</a></li>\n<li><a href=\"https://baike.baidu.com/item/GIT/12647237#3\">百度百科-git</a></li>\n<li><a href=\"https://blog.csdn.net/mine_song/article/details/70770467\">SVN和GIT介绍，区别，使用</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>本文主要介绍git和svn的区别与作用。</p>","more":"<h2 id=\"GIT\"><a href=\"#GIT\" class=\"headerlink\" title=\"GIT\"></a>GIT</h2><p>git是一个应用最广泛的免费的、开源的分布式版本控制系统，github是最常用的提供远程git仓库托管服务的网站。git与常用的集中式版本控制工具Subversion(svn)不同，它采用了分布式版本库的方法，不依赖服务器端软件支持，其最大特点在于开发者可以提交到本地，每个开发者通过克隆（git clone），在本地拷贝一个完整的git仓库。</p>\n<p><strong>工作流程：</strong></p>\n<p>下图是经典的git开发过程。<br><img src=\"/2020/08/01/git-vs-svn/git_process.jpg\" alt=\"git process\"></p>\n<p><strong>功能特性：</strong></p>\n<p>从一般开发者的角度来看，git有以下功能：</p>\n<p>　1．从服务器上克隆完整的Git仓库（包括代码和版本信息）到单机上。<br>　2．在自己的机器上根据不同的开发目的，创建分支，修改代码。<br>　3．在单机上自己创建的分支上提交代码。<br>　4．在单机上合并分支。<br>　5．把服务器上最新版的代码fetch下来，然后跟自己的主分支合并。<br>　6．生成补丁（patch），把补丁发送给主开发者。<br>　7．看主开发者的反馈，如果主开发者发现两个一般开发者之间有冲突（他们之间可以合作解决的冲突），就会要求他们先解决冲突，然后再由其中一个人提交。如果主开发者可以自己解决，或者没有冲突，就通过。<br>　8．一般开发者之间解决冲突的方法，开发者之间可以使用pull 命令解决冲突，解决完冲突之后再向主开发者提交补丁。</p>\n<p>从主开发者的角度看（假设主开发者不用开发代码），git有以下功能：</p>\n<p>　1．查看邮件或者通过其它方式查看一般开发者的提交状态。<br>　2．打上补丁，解决冲突（可以自己解决，也可以要求开发者之间解决以后再重新提交，如果是开源项目，还要决定哪些补丁有用，哪些不用）。<br>　3．向公共服务器提交结果，然后通知所有开发人员。 </p>\n<h2 id=\"SVN\"><a href=\"#SVN\" class=\"headerlink\" title=\"SVN\"></a>SVN</h2><p>SVN是Subversion的简称，是一个开源的版本控制系统，支持大多数常见的操作系统。作为一个开源的版本控制系统，Subversion管理着随时间改变的数据，这些数据放置在一个中央资料档案库（repository）中，这个档案库很像一个普通的文件服务器,不过它会记住每一次文件的变动，这样你就可以把档案恢复到旧的版本，或是浏览文件的变动历史。Subversion是一个通用的系统,可用来管理任何类型的文件，其中包括程序源码。</p>\n<p><strong>工作流程：</strong></p>\n<p>集中式管理的工作流程如下图：<br><img src=\"/2020/08/01/git-vs-svn/svn_process.jpg\" alt=\"svn process\"></p>\n<p>集中式代码管理的核心是服务器，所有开发者在开始新一天的工作之前必须从服务器获取代码，然后开发，最后解决冲突，提交。所有的版本信息都放在服务器上。如果脱离了服务器，开发者基本上可以说是无法工作的。</p>\n<p><strong>功能特性：</strong></p>\n<p>　1．从服务器下载项目组最新代码。<br>　2．进入自己的分支，进行工作，每隔一个小时向服务器自己的分支提交一次代码（很多人都有这个习惯，因为有时候自己对代码改来改去，最后又想还原到前一个小时的版本，或者看看前一个小时自己修改了哪些代码，就需要这样做了）。<br>　3．下班时间快到了，把自己的分支合并到服务器主分支上，一天的工作完成，并反映给服务器。</p>\n<h2 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h2><ol>\n<li><p>适用对象不同。Git适用于参与开源项目的开发者，他们由于水平高，更在乎的是效率而不是易用性。SVN则不同，它适合普通的公司开发团队，使用起来更加容易。</p>\n</li>\n<li><p>使用的场合不同。Git适用于通过Internet，有多个开发角色的单个项目开发。SVN适合企业内部由项目经理统一协调的多个并行项目的开发。</p>\n</li>\n<li><p>权限管理策略不同。Git没有严格的权限管理控制，只要有帐号，就可以导出、导入代码，甚至执行回退操作。SVN则有严格的权限管理，可以按组、按个人进行针对某个子目录的权限控制，区分读、写权限。更严格的，不支持回退操作，保证代码永远可以追踪。</p>\n</li>\n<li><p>分支（branch）的使用范围不同。Git中，你只能针对整个仓库作branch，而且一旦删除，便无法恢复。而SVN中，branch可以针对任何子目录，它本质上是一个拷贝操作，所以，可以建立非常多、层次性的branch，并且，在不需要时将其删除，而以后需要时只要checkout老的SVN版本就可以了。</p>\n</li>\n<li><p>基于第三点，Git适用于单纯的软件项目，典型的就是一些开源项目，比如Linux内核、busybox等。相反，SVN擅长多项目管理。比如，你可以在一个SVN仓库中存放一个手机项目的bsp/设计文档/文件系统/应用程序/自动化编译脚本，或者在一个SVN中存放5款手机项目的文件系统。git中必须建立n（项目数）* m（组件数）个仓库。SVN中只需要最多n或者m个就可以了。</p>\n</li>\n<li><p>Git使用128位ID作为版本号，而且checkout时要注明是哪个branch，而SVN使用一个递增的序列号作为全局唯一的版本号，更加简明易懂。虽然可以使用gittag来建立一些文字化的别名，但是毕竟那只是针对特殊版本。</p>\n</li>\n<li><p>可跟踪性，git的典型开发过程为：建立分支，进行开发，提交到本地master，删除分支。这样做的后果是以前的修改细节会丢失。而在SVN下做同样的事情，不会丢失任何细节。这里是一个有趣的链接，表明了git下典型的工作方式：（以master为核心，不断创建新branch，删除旧branch)。</p>\n</li>\n<li><p>局部更新，局部还原。SVN由于是在每个文件夹建立一个.svn文件夹来实现管理，所以可以很简单实现局部更新或者还原。假如你只希望更新某些部分，则svn可以很好实现。同时代码写错了，同时可以很好实现局部还原，当然git也可以通过历史版本还原，但是无法简单地实现局部还原。</p>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>公司的开发团队在进行项目开发管理时，svn是更好的选择，团队成员共同维护公司的中心版本。若是开源项目，则git更加适合，每个人都可以维护自己专属的版本，同时有github开源社区支持。</p>\n<hr>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://docs.github.com/en/github\">github官网</a></li>\n<li><a href=\"https://baike.baidu.com/item/GIT/12647237#3\">百度百科-git</a></li>\n<li><a href=\"https://blog.csdn.net/mine_song/article/details/70770467\">SVN和GIT介绍，区别，使用</a></li>\n</ol>"},{"title":"git的安装与使用","date":"2020-08-02T20:26:22.000Z","_content":"\n本文介绍git在ubuntu上的安装与使用。\n\n<!-- more -->\n\n## git安装与配置 \nubuntu系统不自带git，需要自己安装：\n\n``` bash\nsudo apt-get install git\n```\n\n安装完成后，设置用户名和邮箱地址：\n\n``` bash\ngit config --global user.name \"YOUR NAME\"\ngit config --global user.email \"YOUR EMAIL ADDRESS\"\n```\n\n## 创建本地版本仓库\n\n在库文件夹比如learngit下初始化git仓库：\n\n``` bash\ngit init\n```\n\n在文件夹中添加文件，比如：classification.cpp，然后可以添加文件到git仓库，分两步进行：\n第一，用git add命令告诉git，将文件添加到仓库：\n\n``` bash\ngit add README.md\n```\n\n第二，用git commit命令告诉git，将文件提交到仓库：\n\n``` bash\ngit commit -m \"add a new file\"\n```\n\n## 添加到远程仓库\n\ngit是分布式版本控制系统，同一个git仓库可以分布到不同的机器上，这儿的机器，可以指公司的git服务器或者github，下面以github为例，介绍怎样将本地git仓库添加到远程仓库。\n\n本地仓库和github的连接有两种方式：\n * HTTPS连接（比如地址为：`https://github.com/gitusername/learngit.git`）\n * SSH连接（比如地址为：`git@github.com:gitusername/learngit.git`）\n\n### HTTPS连接\n\n使用HTTPS连接的不同之处在于：其一，不需要SSH key；其二，上面第一条命令地址要改为HTTP地址：\n\n``` bash\ngit remote add origin https://github.com/gitusername/learngit.git\n```\n\n步骤简单，也是github推荐的连接方式，然而其缺点为速度比SSH连接方式慢。\n\n### SSH连接\n\nSSH加密传输首先要有SSH key，生成过程包括：\n第一步，创建SSH key。输入下面指令：\n\n``` bash\nssh-keygen -t rsa -C \"youremail@example.com\"\n```\n\n之后可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。\n\n第二步，登陆GitHub，打开“Account settings”，“SSH Keys”页面，然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。\n\n然后，在github上创建一个名为learngit的空的仓库（不包含README文件）。\n\n将本地仓库与github仓库相关联并推送内容包含下面两步：\n第一，输入下面命令：\n\n``` bash\ngit remote add origin git@github.com:gitusername/learngit.git\n```\n\n其中，origin代表远程库，是git的默认叫法。\n\n第二，将本地库内容推送到远程库：\n\n``` bash\ngit push -u origin master\n```\n\n由于远程库是空的，第一次推送master分支时，加上了-u参数，git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。再次推送到远程github仓库时，输入简化的命令即可：\n\n``` bash\ngit push origin master\n```\n\n## 从远程仓库克隆\n\n上一节介绍先有本地库，后有远程库的时候，如何关联远程库。假设我们从零开发，最好的方式是先创建远程库，然后，从远程库克隆到本地。\n\n首先在github上创建一个新的仓库，仓库名为learngit，这次要勾选Initialize this repository with a README。\n\n远程库已经准备好了，下一步是用命令git clone克隆一个本地库，也分两种方式。\nSSH连接克隆命令为：\n\n``` bash\ngit clone git@github.com:gitusername/learngit.git\n```\n\nHTTP连接克隆命令为：\n\n``` bash\ngit clone https://github.com/gitusername/learngit.git\n```\n\n在本地仓库修改完代码后，推送到github库：\n\n``` bash\ngit push origin master\n```\n\n---\n\n## git常用命令\n\n### 常规操作\n\n``` bash\ngit status # 查看版本库状态\n\ngit log # 查看提交历史\n\ngit diff #　比较当前工作目录与版本库的差别\n\ngit add file　# 向版本库添加文件\n\ngit add directory/ # 向版本库添加文件夹\n\ngit commit -m \"description\" # 提交并添加描述\n\n```\n\n### 删除文件(夹)\n\n``` bash\ngit rm file # 同时删除本地文件与远程分支文件\ngit rm --cached file # 只删除远程分支文件，保留本地文件\n\ngit rm -r directory #　同时删除本地文件夹与远程分支文件夹\ngit rm -r --cached directory # 只删除远程分支文件夹，保留本地文件夹\n```\n\n### 恢复到指定版本\n项目跟踪工具的一个重要任务之一，就是使我们能够随时恢复到某一阶段的工作。\n\n命令形式：\n\n``` bash\ngit reset [--mixed | --soft | --hard]\n```\n\n其中：\n　`--mixed` 仅是重置索引的位置，而不改变你的工作树中的任何东西，并且提示什么内容还没有被更新。这个是默认的选项。\n　`--soft` 既不触动索引的位置，也不改变工作树中的任何内容，这个选项使你可以将已经提交的东西重新逆转至＂已更新但未提交（Updated but not Check in）＂的状态。\n　`--hard` 将工作树中的内容和头索引都切换至指定的版本位置中，也就是说自 之后的所有的跟踪内容和工作树中的内容都会全部丢失。慎用。\n\n举例：\n撤销上次提交（commit），保留当前所有更改：\n\n``` bash\ngit reset --soft\n```\n\n彻底恢复到上次提交的版本，放弃当前所有更改：\n\n``` bash\ngit reset --hard\n```\n\n彻底返回到最近两次提交之前的版本：\n\n``` bash\ngit reset --hard HEAD~2\n```\n\n### 管理分支\n\n如果项目存在多个分支就需要进行分支管理。\n\n查看分支:\n\n``` bash\ngit branch\n```\n\n使用以下命令创建分支并将创建的分支设置为当前工作分支：\n\n``` bash\ngit branch new_branch\ngit checkout new_branch\n或者\ngit checkout -b new_branch\n```\n\n删除分支：\n\n``` bash\ngit branch -d new_branch # 先检查分支是否合并到其他分支上，若没有合并则无法删除\ngit branch -D new_branch # 直接删除分支，不会检查分支状态\n```\n\n查看版本库的发展记录:\n\n``` bash\ngit show-branch\n```\n\n查看两个版本的差异情况：\n\n``` bash\ngit diff B1 B2\n```\n\n合并其他分支到主分支上：\n\n``` bash\ngit check master\ngit merge -m \"merge from new_branch\" new_branch\n或者\ngit pull . new_branch\n```\n\n合并远程库到本地主分支：\n\n``` bash\ngit pull --rebase\n```\n\n**注意：** \n* 执行 `git pull --rebase` 的时候必须保持本地目录干净。即：不能存在状态为 modified 的文件（存在Untracked files是没关系的）。\n* 如果出现冲突，可以选择手动解决冲突后继续 rebase，也可以用 `git rebase --abort` 放弃本次 rebase。\n\n最后，将本地提交好的分支推送到远程仓库：\n\n``` bash\ngit push origin master\n```\n\n---\n\n## 参考\n1. [git和github在ubuntu上的使用](https://blog.csdn.net/u012526120/article/details/49401871)\n2. [git回到指定版本命令](https://blog.csdn.net/pcyph/article/details/44035935)\n3. [git pull --rebase的正确使用](https://juejin.im/post/6844903895160881166)\n\n","source":"_posts/git.md","raw":"---\ntitle: git的安装与使用\ndate: 2020-08-02 22:26:22\ntags:\n- git\n- tutorial\ncategories:\n- [版本控制（git svn）]\n---\n\n本文介绍git在ubuntu上的安装与使用。\n\n<!-- more -->\n\n## git安装与配置 \nubuntu系统不自带git，需要自己安装：\n\n``` bash\nsudo apt-get install git\n```\n\n安装完成后，设置用户名和邮箱地址：\n\n``` bash\ngit config --global user.name \"YOUR NAME\"\ngit config --global user.email \"YOUR EMAIL ADDRESS\"\n```\n\n## 创建本地版本仓库\n\n在库文件夹比如learngit下初始化git仓库：\n\n``` bash\ngit init\n```\n\n在文件夹中添加文件，比如：classification.cpp，然后可以添加文件到git仓库，分两步进行：\n第一，用git add命令告诉git，将文件添加到仓库：\n\n``` bash\ngit add README.md\n```\n\n第二，用git commit命令告诉git，将文件提交到仓库：\n\n``` bash\ngit commit -m \"add a new file\"\n```\n\n## 添加到远程仓库\n\ngit是分布式版本控制系统，同一个git仓库可以分布到不同的机器上，这儿的机器，可以指公司的git服务器或者github，下面以github为例，介绍怎样将本地git仓库添加到远程仓库。\n\n本地仓库和github的连接有两种方式：\n * HTTPS连接（比如地址为：`https://github.com/gitusername/learngit.git`）\n * SSH连接（比如地址为：`git@github.com:gitusername/learngit.git`）\n\n### HTTPS连接\n\n使用HTTPS连接的不同之处在于：其一，不需要SSH key；其二，上面第一条命令地址要改为HTTP地址：\n\n``` bash\ngit remote add origin https://github.com/gitusername/learngit.git\n```\n\n步骤简单，也是github推荐的连接方式，然而其缺点为速度比SSH连接方式慢。\n\n### SSH连接\n\nSSH加密传输首先要有SSH key，生成过程包括：\n第一步，创建SSH key。输入下面指令：\n\n``` bash\nssh-keygen -t rsa -C \"youremail@example.com\"\n```\n\n之后可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。\n\n第二步，登陆GitHub，打开“Account settings”，“SSH Keys”页面，然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。\n\n然后，在github上创建一个名为learngit的空的仓库（不包含README文件）。\n\n将本地仓库与github仓库相关联并推送内容包含下面两步：\n第一，输入下面命令：\n\n``` bash\ngit remote add origin git@github.com:gitusername/learngit.git\n```\n\n其中，origin代表远程库，是git的默认叫法。\n\n第二，将本地库内容推送到远程库：\n\n``` bash\ngit push -u origin master\n```\n\n由于远程库是空的，第一次推送master分支时，加上了-u参数，git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。再次推送到远程github仓库时，输入简化的命令即可：\n\n``` bash\ngit push origin master\n```\n\n## 从远程仓库克隆\n\n上一节介绍先有本地库，后有远程库的时候，如何关联远程库。假设我们从零开发，最好的方式是先创建远程库，然后，从远程库克隆到本地。\n\n首先在github上创建一个新的仓库，仓库名为learngit，这次要勾选Initialize this repository with a README。\n\n远程库已经准备好了，下一步是用命令git clone克隆一个本地库，也分两种方式。\nSSH连接克隆命令为：\n\n``` bash\ngit clone git@github.com:gitusername/learngit.git\n```\n\nHTTP连接克隆命令为：\n\n``` bash\ngit clone https://github.com/gitusername/learngit.git\n```\n\n在本地仓库修改完代码后，推送到github库：\n\n``` bash\ngit push origin master\n```\n\n---\n\n## git常用命令\n\n### 常规操作\n\n``` bash\ngit status # 查看版本库状态\n\ngit log # 查看提交历史\n\ngit diff #　比较当前工作目录与版本库的差别\n\ngit add file　# 向版本库添加文件\n\ngit add directory/ # 向版本库添加文件夹\n\ngit commit -m \"description\" # 提交并添加描述\n\n```\n\n### 删除文件(夹)\n\n``` bash\ngit rm file # 同时删除本地文件与远程分支文件\ngit rm --cached file # 只删除远程分支文件，保留本地文件\n\ngit rm -r directory #　同时删除本地文件夹与远程分支文件夹\ngit rm -r --cached directory # 只删除远程分支文件夹，保留本地文件夹\n```\n\n### 恢复到指定版本\n项目跟踪工具的一个重要任务之一，就是使我们能够随时恢复到某一阶段的工作。\n\n命令形式：\n\n``` bash\ngit reset [--mixed | --soft | --hard]\n```\n\n其中：\n　`--mixed` 仅是重置索引的位置，而不改变你的工作树中的任何东西，并且提示什么内容还没有被更新。这个是默认的选项。\n　`--soft` 既不触动索引的位置，也不改变工作树中的任何内容，这个选项使你可以将已经提交的东西重新逆转至＂已更新但未提交（Updated but not Check in）＂的状态。\n　`--hard` 将工作树中的内容和头索引都切换至指定的版本位置中，也就是说自 之后的所有的跟踪内容和工作树中的内容都会全部丢失。慎用。\n\n举例：\n撤销上次提交（commit），保留当前所有更改：\n\n``` bash\ngit reset --soft\n```\n\n彻底恢复到上次提交的版本，放弃当前所有更改：\n\n``` bash\ngit reset --hard\n```\n\n彻底返回到最近两次提交之前的版本：\n\n``` bash\ngit reset --hard HEAD~2\n```\n\n### 管理分支\n\n如果项目存在多个分支就需要进行分支管理。\n\n查看分支:\n\n``` bash\ngit branch\n```\n\n使用以下命令创建分支并将创建的分支设置为当前工作分支：\n\n``` bash\ngit branch new_branch\ngit checkout new_branch\n或者\ngit checkout -b new_branch\n```\n\n删除分支：\n\n``` bash\ngit branch -d new_branch # 先检查分支是否合并到其他分支上，若没有合并则无法删除\ngit branch -D new_branch # 直接删除分支，不会检查分支状态\n```\n\n查看版本库的发展记录:\n\n``` bash\ngit show-branch\n```\n\n查看两个版本的差异情况：\n\n``` bash\ngit diff B1 B2\n```\n\n合并其他分支到主分支上：\n\n``` bash\ngit check master\ngit merge -m \"merge from new_branch\" new_branch\n或者\ngit pull . new_branch\n```\n\n合并远程库到本地主分支：\n\n``` bash\ngit pull --rebase\n```\n\n**注意：** \n* 执行 `git pull --rebase` 的时候必须保持本地目录干净。即：不能存在状态为 modified 的文件（存在Untracked files是没关系的）。\n* 如果出现冲突，可以选择手动解决冲突后继续 rebase，也可以用 `git rebase --abort` 放弃本次 rebase。\n\n最后，将本地提交好的分支推送到远程仓库：\n\n``` bash\ngit push origin master\n```\n\n---\n\n## 参考\n1. [git和github在ubuntu上的使用](https://blog.csdn.net/u012526120/article/details/49401871)\n2. [git回到指定版本命令](https://blog.csdn.net/pcyph/article/details/44035935)\n3. [git pull --rebase的正确使用](https://juejin.im/post/6844903895160881166)\n\n","slug":"git","published":1,"updated":"2020-08-07T10:07:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdypyf70000am4k2581p9ohp","content":"<p>本文介绍git在ubuntu上的安装与使用。</p>\n<a id=\"more\"></a>\n<h2 id=\"git安装与配置\"><a href=\"#git安装与配置\" class=\"headerlink\" title=\"git安装与配置\"></a>git安装与配置</h2><p>ubuntu系统不自带git，需要自己安装：</p>\n<pre><code class=\"hljs bash\">sudo apt-get install git</code></pre>\n<p>安装完成后，设置用户名和邮箱地址：</p>\n<pre><code class=\"hljs bash\">git config --global user.name <span class=\"hljs-string\">&quot;YOUR NAME&quot;</span>\ngit config --global user.email <span class=\"hljs-string\">&quot;YOUR EMAIL ADDRESS&quot;</span></code></pre>\n<h2 id=\"创建本地版本仓库\"><a href=\"#创建本地版本仓库\" class=\"headerlink\" title=\"创建本地版本仓库\"></a>创建本地版本仓库</h2><p>在库文件夹比如learngit下初始化git仓库：</p>\n<pre><code class=\"hljs bash\">git init</code></pre>\n<p>在文件夹中添加文件，比如：classification.cpp，然后可以添加文件到git仓库，分两步进行：<br>第一，用git add命令告诉git，将文件添加到仓库：</p>\n<pre><code class=\"hljs bash\">git add README.md</code></pre>\n<p>第二，用git commit命令告诉git，将文件提交到仓库：</p>\n<pre><code class=\"hljs bash\">git commit -m <span class=\"hljs-string\">&quot;add a new file&quot;</span></code></pre>\n<h2 id=\"添加到远程仓库\"><a href=\"#添加到远程仓库\" class=\"headerlink\" title=\"添加到远程仓库\"></a>添加到远程仓库</h2><p>git是分布式版本控制系统，同一个git仓库可以分布到不同的机器上，这儿的机器，可以指公司的git服务器或者github，下面以github为例，介绍怎样将本地git仓库添加到远程仓库。</p>\n<p>本地仓库和github的连接有两种方式：</p>\n<ul>\n<li>HTTPS连接（比如地址为：<code>https://github.com/gitusername/learngit.git</code>）</li>\n<li>SSH连接（比如地址为：<a href=\"mailto:`git@github.com\">`git@github.com</a>:gitusername/learngit.git`）</li>\n</ul>\n<h3 id=\"HTTPS连接\"><a href=\"#HTTPS连接\" class=\"headerlink\" title=\"HTTPS连接\"></a>HTTPS连接</h3><p>使用HTTPS连接的不同之处在于：其一，不需要SSH key；其二，上面第一条命令地址要改为HTTP地址：</p>\n<pre><code class=\"hljs bash\">git remote add origin https://github.com/gitusername/learngit.git</code></pre>\n<p>步骤简单，也是github推荐的连接方式，然而其缺点为速度比SSH连接方式慢。</p>\n<h3 id=\"SSH连接\"><a href=\"#SSH连接\" class=\"headerlink\" title=\"SSH连接\"></a>SSH连接</h3><p>SSH加密传输首先要有SSH key，生成过程包括：<br>第一步，创建SSH key。输入下面指令：</p>\n<pre><code class=\"hljs bash\">ssh-keygen -t rsa -C <span class=\"hljs-string\">&quot;youremail@example.com&quot;</span></code></pre>\n<p>之后可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p>\n<p>第二步，登陆GitHub，打开“Account settings”，“SSH Keys”页面，然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。</p>\n<p>然后，在github上创建一个名为learngit的空的仓库（不包含README文件）。</p>\n<p>将本地仓库与github仓库相关联并推送内容包含下面两步：<br>第一，输入下面命令：</p>\n<pre><code class=\"hljs bash\">git remote add origin git@github.com:gitusername/learngit.git</code></pre>\n<p>其中，origin代表远程库，是git的默认叫法。</p>\n<p>第二，将本地库内容推送到远程库：</p>\n<pre><code class=\"hljs bash\">git push -u origin master</code></pre>\n<p>由于远程库是空的，第一次推送master分支时，加上了-u参数，git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。再次推送到远程github仓库时，输入简化的命令即可：</p>\n<pre><code class=\"hljs bash\">git push origin master</code></pre>\n<h2 id=\"从远程仓库克隆\"><a href=\"#从远程仓库克隆\" class=\"headerlink\" title=\"从远程仓库克隆\"></a>从远程仓库克隆</h2><p>上一节介绍先有本地库，后有远程库的时候，如何关联远程库。假设我们从零开发，最好的方式是先创建远程库，然后，从远程库克隆到本地。</p>\n<p>首先在github上创建一个新的仓库，仓库名为learngit，这次要勾选Initialize this repository with a README。</p>\n<p>远程库已经准备好了，下一步是用命令git clone克隆一个本地库，也分两种方式。<br>SSH连接克隆命令为：</p>\n<pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">clone</span> git@github.com:gitusername/learngit.git</code></pre>\n<p>HTTP连接克隆命令为：</p>\n<pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">clone</span> https://github.com/gitusername/learngit.git</code></pre>\n<p>在本地仓库修改完代码后，推送到github库：</p>\n<pre><code class=\"hljs bash\">git push origin master</code></pre>\n<hr>\n<h2 id=\"git常用命令\"><a href=\"#git常用命令\" class=\"headerlink\" title=\"git常用命令\"></a>git常用命令</h2><h3 id=\"常规操作\"><a href=\"#常规操作\" class=\"headerlink\" title=\"常规操作\"></a>常规操作</h3><pre><code class=\"hljs bash\">git status <span class=\"hljs-comment\"># 查看版本库状态</span>\n\ngit <span class=\"hljs-built_in\">log</span> <span class=\"hljs-comment\"># 查看提交历史</span>\n\ngit diff <span class=\"hljs-comment\">#　比较当前工作目录与版本库的差别</span>\n\ngit add file　<span class=\"hljs-comment\"># 向版本库添加文件</span>\n\ngit add directory/ <span class=\"hljs-comment\"># 向版本库添加文件夹</span>\n\ngit commit -m <span class=\"hljs-string\">&quot;description&quot;</span> <span class=\"hljs-comment\"># 提交并添加描述</span>\n</code></pre>\n<h3 id=\"删除文件-夹\"><a href=\"#删除文件-夹\" class=\"headerlink\" title=\"删除文件(夹)\"></a>删除文件(夹)</h3><pre><code class=\"hljs bash\">git rm file <span class=\"hljs-comment\"># 同时删除本地文件与远程分支文件</span>\ngit rm --cached file <span class=\"hljs-comment\"># 只删除远程分支文件，保留本地文件</span>\n\ngit rm -r directory <span class=\"hljs-comment\">#　同时删除本地文件夹与远程分支文件夹</span>\ngit rm -r --cached directory <span class=\"hljs-comment\"># 只删除远程分支文件夹，保留本地文件夹</span></code></pre>\n<h3 id=\"恢复到指定版本\"><a href=\"#恢复到指定版本\" class=\"headerlink\" title=\"恢复到指定版本\"></a>恢复到指定版本</h3><p>项目跟踪工具的一个重要任务之一，就是使我们能够随时恢复到某一阶段的工作。</p>\n<p>命令形式：</p>\n<pre><code class=\"hljs bash\">git reset [--mixed | --soft | --hard]</code></pre>\n<p>其中：<br>　<code>--mixed</code> 仅是重置索引的位置，而不改变你的工作树中的任何东西，并且提示什么内容还没有被更新。这个是默认的选项。<br>　<code>--soft</code> 既不触动索引的位置，也不改变工作树中的任何内容，这个选项使你可以将已经提交的东西重新逆转至＂已更新但未提交（Updated but not Check in）＂的状态。<br>　<code>--hard</code> 将工作树中的内容和头索引都切换至指定的版本位置中，也就是说自 之后的所有的跟踪内容和工作树中的内容都会全部丢失。慎用。</p>\n<p>举例：<br>撤销上次提交（commit），保留当前所有更改：</p>\n<pre><code class=\"hljs bash\">git reset --soft</code></pre>\n<p>彻底恢复到上次提交的版本，放弃当前所有更改：</p>\n<pre><code class=\"hljs bash\">git reset --hard</code></pre>\n<p>彻底返回到最近两次提交之前的版本：</p>\n<pre><code class=\"hljs bash\">git reset --hard HEAD~2</code></pre>\n<h3 id=\"管理分支\"><a href=\"#管理分支\" class=\"headerlink\" title=\"管理分支\"></a>管理分支</h3><p>如果项目存在多个分支就需要进行分支管理。</p>\n<p>查看分支:</p>\n<pre><code class=\"hljs bash\">git branch</code></pre>\n<p>使用以下命令创建分支并将创建的分支设置为当前工作分支：</p>\n<pre><code class=\"hljs bash\">git branch new_branch\ngit checkout new_branch\n或者\ngit checkout -b new_branch</code></pre>\n<p>删除分支：</p>\n<pre><code class=\"hljs bash\">git branch -d new_branch <span class=\"hljs-comment\"># 先检查分支是否合并到其他分支上，若没有合并则无法删除</span>\ngit branch -D new_branch <span class=\"hljs-comment\"># 直接删除分支，不会检查分支状态</span></code></pre>\n<p>查看版本库的发展记录:</p>\n<pre><code class=\"hljs bash\">git show-branch</code></pre>\n<p>查看两个版本的差异情况：</p>\n<pre><code class=\"hljs bash\">git diff B1 B2</code></pre>\n<p>合并其他分支到主分支上：</p>\n<pre><code class=\"hljs bash\">git check master\ngit merge -m <span class=\"hljs-string\">&quot;merge from new_branch&quot;</span> new_branch\n或者\ngit pull . new_branch</code></pre>\n<p>合并远程库到本地主分支：</p>\n<pre><code class=\"hljs bash\">git pull --rebase</code></pre>\n<p><strong>注意：</strong> </p>\n<ul>\n<li>执行 <code>git pull --rebase</code> 的时候必须保持本地目录干净。即：不能存在状态为 modified 的文件（存在Untracked files是没关系的）。</li>\n<li>如果出现冲突，可以选择手动解决冲突后继续 rebase，也可以用 <code>git rebase --abort</code> 放弃本次 rebase。</li>\n</ul>\n<p>最后，将本地提交好的分支推送到远程仓库：</p>\n<pre><code class=\"hljs bash\">git push origin master</code></pre>\n<hr>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://blog.csdn.net/u012526120/article/details/49401871\">git和github在ubuntu上的使用</a></li>\n<li><a href=\"https://blog.csdn.net/pcyph/article/details/44035935\">git回到指定版本命令</a></li>\n<li><a href=\"https://juejin.im/post/6844903895160881166\">git pull –rebase的正确使用</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>本文介绍git在ubuntu上的安装与使用。</p>","more":"<h2 id=\"git安装与配置\"><a href=\"#git安装与配置\" class=\"headerlink\" title=\"git安装与配置\"></a>git安装与配置</h2><p>ubuntu系统不自带git，需要自己安装：</p>\n<pre><code class=\"hljs bash\">sudo apt-get install git</code></pre>\n<p>安装完成后，设置用户名和邮箱地址：</p>\n<pre><code class=\"hljs bash\">git config --global user.name <span class=\"hljs-string\">&quot;YOUR NAME&quot;</span>\ngit config --global user.email <span class=\"hljs-string\">&quot;YOUR EMAIL ADDRESS&quot;</span></code></pre>\n<h2 id=\"创建本地版本仓库\"><a href=\"#创建本地版本仓库\" class=\"headerlink\" title=\"创建本地版本仓库\"></a>创建本地版本仓库</h2><p>在库文件夹比如learngit下初始化git仓库：</p>\n<pre><code class=\"hljs bash\">git init</code></pre>\n<p>在文件夹中添加文件，比如：classification.cpp，然后可以添加文件到git仓库，分两步进行：<br>第一，用git add命令告诉git，将文件添加到仓库：</p>\n<pre><code class=\"hljs bash\">git add README.md</code></pre>\n<p>第二，用git commit命令告诉git，将文件提交到仓库：</p>\n<pre><code class=\"hljs bash\">git commit -m <span class=\"hljs-string\">&quot;add a new file&quot;</span></code></pre>\n<h2 id=\"添加到远程仓库\"><a href=\"#添加到远程仓库\" class=\"headerlink\" title=\"添加到远程仓库\"></a>添加到远程仓库</h2><p>git是分布式版本控制系统，同一个git仓库可以分布到不同的机器上，这儿的机器，可以指公司的git服务器或者github，下面以github为例，介绍怎样将本地git仓库添加到远程仓库。</p>\n<p>本地仓库和github的连接有两种方式：</p>\n<ul>\n<li>HTTPS连接（比如地址为：<code>https://github.com/gitusername/learngit.git</code>）</li>\n<li>SSH连接（比如地址为：<a href=\"mailto:`git@github.com\">`git@github.com</a>:gitusername/learngit.git`）</li>\n</ul>\n<h3 id=\"HTTPS连接\"><a href=\"#HTTPS连接\" class=\"headerlink\" title=\"HTTPS连接\"></a>HTTPS连接</h3><p>使用HTTPS连接的不同之处在于：其一，不需要SSH key；其二，上面第一条命令地址要改为HTTP地址：</p>\n<pre><code class=\"hljs bash\">git remote add origin https://github.com/gitusername/learngit.git</code></pre>\n<p>步骤简单，也是github推荐的连接方式，然而其缺点为速度比SSH连接方式慢。</p>\n<h3 id=\"SSH连接\"><a href=\"#SSH连接\" class=\"headerlink\" title=\"SSH连接\"></a>SSH连接</h3><p>SSH加密传输首先要有SSH key，生成过程包括：<br>第一步，创建SSH key。输入下面指令：</p>\n<pre><code class=\"hljs bash\">ssh-keygen -t rsa -C <span class=\"hljs-string\">&quot;youremail@example.com&quot;</span></code></pre>\n<p>之后可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p>\n<p>第二步，登陆GitHub，打开“Account settings”，“SSH Keys”页面，然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。</p>\n<p>然后，在github上创建一个名为learngit的空的仓库（不包含README文件）。</p>\n<p>将本地仓库与github仓库相关联并推送内容包含下面两步：<br>第一，输入下面命令：</p>\n<pre><code class=\"hljs bash\">git remote add origin git@github.com:gitusername/learngit.git</code></pre>\n<p>其中，origin代表远程库，是git的默认叫法。</p>\n<p>第二，将本地库内容推送到远程库：</p>\n<pre><code class=\"hljs bash\">git push -u origin master</code></pre>\n<p>由于远程库是空的，第一次推送master分支时，加上了-u参数，git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。再次推送到远程github仓库时，输入简化的命令即可：</p>\n<pre><code class=\"hljs bash\">git push origin master</code></pre>\n<h2 id=\"从远程仓库克隆\"><a href=\"#从远程仓库克隆\" class=\"headerlink\" title=\"从远程仓库克隆\"></a>从远程仓库克隆</h2><p>上一节介绍先有本地库，后有远程库的时候，如何关联远程库。假设我们从零开发，最好的方式是先创建远程库，然后，从远程库克隆到本地。</p>\n<p>首先在github上创建一个新的仓库，仓库名为learngit，这次要勾选Initialize this repository with a README。</p>\n<p>远程库已经准备好了，下一步是用命令git clone克隆一个本地库，也分两种方式。<br>SSH连接克隆命令为：</p>\n<pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">clone</span> git@github.com:gitusername/learngit.git</code></pre>\n<p>HTTP连接克隆命令为：</p>\n<pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">clone</span> https://github.com/gitusername/learngit.git</code></pre>\n<p>在本地仓库修改完代码后，推送到github库：</p>\n<pre><code class=\"hljs bash\">git push origin master</code></pre>\n<hr>\n<h2 id=\"git常用命令\"><a href=\"#git常用命令\" class=\"headerlink\" title=\"git常用命令\"></a>git常用命令</h2><h3 id=\"常规操作\"><a href=\"#常规操作\" class=\"headerlink\" title=\"常规操作\"></a>常规操作</h3><pre><code class=\"hljs bash\">git status <span class=\"hljs-comment\"># 查看版本库状态</span>\n\ngit <span class=\"hljs-built_in\">log</span> <span class=\"hljs-comment\"># 查看提交历史</span>\n\ngit diff <span class=\"hljs-comment\">#　比较当前工作目录与版本库的差别</span>\n\ngit add file　<span class=\"hljs-comment\"># 向版本库添加文件</span>\n\ngit add directory/ <span class=\"hljs-comment\"># 向版本库添加文件夹</span>\n\ngit commit -m <span class=\"hljs-string\">&quot;description&quot;</span> <span class=\"hljs-comment\"># 提交并添加描述</span>\n</code></pre>\n<h3 id=\"删除文件-夹\"><a href=\"#删除文件-夹\" class=\"headerlink\" title=\"删除文件(夹)\"></a>删除文件(夹)</h3><pre><code class=\"hljs bash\">git rm file <span class=\"hljs-comment\"># 同时删除本地文件与远程分支文件</span>\ngit rm --cached file <span class=\"hljs-comment\"># 只删除远程分支文件，保留本地文件</span>\n\ngit rm -r directory <span class=\"hljs-comment\">#　同时删除本地文件夹与远程分支文件夹</span>\ngit rm -r --cached directory <span class=\"hljs-comment\"># 只删除远程分支文件夹，保留本地文件夹</span></code></pre>\n<h3 id=\"恢复到指定版本\"><a href=\"#恢复到指定版本\" class=\"headerlink\" title=\"恢复到指定版本\"></a>恢复到指定版本</h3><p>项目跟踪工具的一个重要任务之一，就是使我们能够随时恢复到某一阶段的工作。</p>\n<p>命令形式：</p>\n<pre><code class=\"hljs bash\">git reset [--mixed | --soft | --hard]</code></pre>\n<p>其中：<br>　<code>--mixed</code> 仅是重置索引的位置，而不改变你的工作树中的任何东西，并且提示什么内容还没有被更新。这个是默认的选项。<br>　<code>--soft</code> 既不触动索引的位置，也不改变工作树中的任何内容，这个选项使你可以将已经提交的东西重新逆转至＂已更新但未提交（Updated but not Check in）＂的状态。<br>　<code>--hard</code> 将工作树中的内容和头索引都切换至指定的版本位置中，也就是说自 之后的所有的跟踪内容和工作树中的内容都会全部丢失。慎用。</p>\n<p>举例：<br>撤销上次提交（commit），保留当前所有更改：</p>\n<pre><code class=\"hljs bash\">git reset --soft</code></pre>\n<p>彻底恢复到上次提交的版本，放弃当前所有更改：</p>\n<pre><code class=\"hljs bash\">git reset --hard</code></pre>\n<p>彻底返回到最近两次提交之前的版本：</p>\n<pre><code class=\"hljs bash\">git reset --hard HEAD~2</code></pre>\n<h3 id=\"管理分支\"><a href=\"#管理分支\" class=\"headerlink\" title=\"管理分支\"></a>管理分支</h3><p>如果项目存在多个分支就需要进行分支管理。</p>\n<p>查看分支:</p>\n<pre><code class=\"hljs bash\">git branch</code></pre>\n<p>使用以下命令创建分支并将创建的分支设置为当前工作分支：</p>\n<pre><code class=\"hljs bash\">git branch new_branch\ngit checkout new_branch\n或者\ngit checkout -b new_branch</code></pre>\n<p>删除分支：</p>\n<pre><code class=\"hljs bash\">git branch -d new_branch <span class=\"hljs-comment\"># 先检查分支是否合并到其他分支上，若没有合并则无法删除</span>\ngit branch -D new_branch <span class=\"hljs-comment\"># 直接删除分支，不会检查分支状态</span></code></pre>\n<p>查看版本库的发展记录:</p>\n<pre><code class=\"hljs bash\">git show-branch</code></pre>\n<p>查看两个版本的差异情况：</p>\n<pre><code class=\"hljs bash\">git diff B1 B2</code></pre>\n<p>合并其他分支到主分支上：</p>\n<pre><code class=\"hljs bash\">git check master\ngit merge -m <span class=\"hljs-string\">&quot;merge from new_branch&quot;</span> new_branch\n或者\ngit pull . new_branch</code></pre>\n<p>合并远程库到本地主分支：</p>\n<pre><code class=\"hljs bash\">git pull --rebase</code></pre>\n<p><strong>注意：</strong> </p>\n<ul>\n<li>执行 <code>git pull --rebase</code> 的时候必须保持本地目录干净。即：不能存在状态为 modified 的文件（存在Untracked files是没关系的）。</li>\n<li>如果出现冲突，可以选择手动解决冲突后继续 rebase，也可以用 <code>git rebase --abort</code> 放弃本次 rebase。</li>\n</ul>\n<p>最后，将本地提交好的分支推送到远程仓库：</p>\n<pre><code class=\"hljs bash\">git push origin master</code></pre>\n<hr>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://blog.csdn.net/u012526120/article/details/49401871\">git和github在ubuntu上的使用</a></li>\n<li><a href=\"https://blog.csdn.net/pcyph/article/details/44035935\">git回到指定版本命令</a></li>\n<li><a href=\"https://juejin.im/post/6844903895160881166\">git pull –rebase的正确使用</a></li>\n</ol>"},{"title":"Hello Hexo","date":"2020-07-29T15:55:05.000Z","_content":"\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-hexo.md","raw":"---\ntitle: Hello Hexo\ndate: 2020-07-29 17:55:05\ntags: \n- tutorial\ncategories:\n- [hexo]\n---\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-hexo","published":1,"updated":"2020-08-07T10:02:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdypyf70000bm4k209gqfmqz","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<a id=\"more\"></a>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span></code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"hljs bash\">$ hexo server</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"hljs bash\">$ hexo generate</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"hljs bash\">$ hexo deploy</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>","more":"<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span></code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"hljs bash\">$ hexo server</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"hljs bash\">$ hexo generate</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"hljs bash\">$ hexo deploy</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>"},{"title":"svn的安裝与使用","date":"2020-08-03T21:55:05.000Z","_content":"\n本文介绍如何在ubuntu上的搭建svn服务器以及如何使用svn。\n\n<!-- more -->\n\n\n## 安装svn服务器软件subversion\nubuntu系统不自带svn，需要自己安装：\n\n``` bash\nsudo apt-get install subversion\n```\n\n## 创建svn目录\n在home下创建svn文件夹：\n\n``` bash\nsudo mkdir /home/svn\n```\n\n在新创建的svn文件夹下创建repo文件夹（svn的版本仓库存放目录）：\n\n``` bash\nsudo mkdir /home/svn/repo\n```\n\n## 创建svn版本仓库\n\n``` bash\nsudo svnadmin create /home/svn/repo\n```\n\n## 配置svn服务器\n\n创建svn用户组：\n\n``` bash\nsudo addgroup subversion\n```\n\n将自己（比如：peng）加入到svn用户组：\n\n``` bash\nsudo usermod -a -G subversion peng\n```\n\n更改权限：\n\n``` bash\nsudo chown -R peng:subversion /home/svn/repo\nsudo chmod -R g+rws /home/svn/repo\n```\n\n## 访问svn服务器\n访问svn服务器有以下几种协议，下面会一一介绍：\n<table>\n  <tr>\n    <th>协议</th>\n    <th>方式</th>\n  </tr>\n  <tr>\n    <td>file://　</td>\n    <td>直接访问（在相同主机上)</td>\n  </tr>\n  <tr>\n    <td>svn://</td>\n    <td>通过svn用户协议访问</td>\n  </tr>\n  <tr>\n    <td>svn+ssh://</td>\n    <td>和svn://相同，只是通过ssh隧道</td>\n  </tr>\n  <tr>\n    <td>http:// </td>\n    <td>通过WebDAV协议访问subversion支持的Apache 2 web服务器</td>\n  </tr>\n　　<tr>\n    <td>https://</td>\n    <td>和http://次相同，只是用了SSL加密</td>\n  </tr>\n</table>\n\n### file://\n\n不需要做任何设置，直接通过下方指令即可获取本地svn服务器仓库中的资源：\n\n``` bash\nsvn co file:///home/svn/repo\n或者\nsvn co file://localhost/home/svn/repo\n```\n\n### svn://\n\n需要配置/home/svn/repo/conf目录中的文件。\n\n1. svnserve.conf: 服务配置文件：\n\n``` bash\n#匿名用户不可读\nanon-access = none\n#权限用户可写\nauth-access = write\n#密码文件为passwd\npassword-db = passwd\n#权限文件为authz\nauthz-db = authz\n```\n\n2. authz: 用户权限配置文件：\n\n``` bash\n[groups]\nsubversion = peng # subversion组的用户\n\n[/] # 必须写/，因为这表示从仓库的目录开始设置权限\n@subversion = rw # subversion组有rw(读写权限)\n* = r # 所有人有r(读权限)\n```\n\n3. passwd: 用户密码配置文件：\n\n``` bash\n[users]\n # harry = harryssecret\n # sally = sallyssecret\npeng = 12345 # 设定用户peng的密码是12345，是的没错，密码是明文的。\n```\n\n启动svn服务器：\n\n``` bash\nsvnserve -d -r /home/svn/repo\n```\n(-d: 表示在守护模式运行，-r: 指定服务器的根目录)\n默认端口为3690，可以根据需要自行更改或者做些其它设置，详情请见`svnserve --help`。\n\n停止svn服务器：\n\n``` bash\nkillall svnserve\n```\n\n开机默认启动：\n\n可以添加一个自动启动脚本`/etc/init.d/subversion`，设置 svn 服务开机默认启动。\n\n``` bash\n#!/bin/sh\n\n# start/stop subversion daemon\n\ntest -f /usr/bin/svnserve || exit 0\n\nOPTIONS=\"-d -T -r /home/svn/repo\"\n\ncase \"$1\" in\n start)\n  echo -n \"Starting subversion daemon:\"\n  echo -n \" svnserve\"\n  start-stop-daemon --start --quiet --oknodo --chuid root:root --exec /usr/bin/svnserve -- $OPTIONS\n  echo \".\"\n  ;;\n\n stop)\n  echo -n \"Stopping subversion daemon:\"\n  echo -n \" svnserve\"\n  start-stop-daemon --stop --quiet --oknodo --exec /usr/bin/svnserve\n  echo \".\"\n  ;;\n\n reload)\n  ;;\n\n force-reload)\n  $0 restart\n  ;;\n\n restart)\n  $0 stop\n  $0 start\n  ;;\n\n *)\n  echo \"Usage: /etc/init.d/subversion (start|stop|reload|restart)\"\n  exit 1\n  ;;\n\nesac\n\nexit 0\n```\n\n添加执行权限：\n\n``` bash\nsudo chmod u+x /etc/init.d/subversion\n```\n\n测试一下从脚本启动：\n\n``` bash\nsudo /etc/init.d/subversion start\n```\n\n将此脚本设置为开机默认启动：\n\n``` bash\nsudo update-rc.d -f subversion defaults\n```\n\n在svnserve已开启的情况下，通过下方指令获取svn服务器仓库中的资源：\n\n``` bash\nsvn co svn://hostname repo --username peng\n```\n\n### svn+ssh://\n\n设置同svn://，在ssh服务已经打开的情况下，通过下方指令即可获取svn服务器仓库中的资源：\n\n``` bash\nsvn co svn+ssh://hostname/home/svn/repo repo --username peng\n```\n\n注意：这里必须加上仓库的完整路径（/home/svn/repo）, 而svn://方式则不用。\n\n\n### http://\n\n需要安装并配置Apache2 web server。\n\n安装Apache2：\n\n``` bash\nsudo apt-get install apache2\n```\n\n配置Apache2：\n\n在`etc/apache2/mods_available/dav_svn.conf`文件中添加以下代码：\n\n``` bash\n<Location /home/svn/repo>\n    DAV svn\n    SVNPath /home/svn/repo\n    AuthType Basic\n    AuthName \"subversion repository\"\n    AuthUserFile /etc/subversion/passwd\n    Require valid-user\n</Location>\n```\n\n添加Apache2用户www-data并加入到subversion组中：\n\n``` bash\nsudo adduser www-data subversion\n```\n\n重启Apache2服务：\n\n``` bash\nsudo /etc/init.d/apache2 restart\n```\n\n创建用户和密码文件（`/etc/subversion/passwd`）：\n\n``` bash\nsudo htpasswd -c /etc/subversion/passwd peng\n```\n按照提示输入密码即可。\n通过下面的命令可添加新用户（new_user）：\n``` bash\nsudo htpasswd /etc/subversion/passwd new_user\n```\n\n配置完成，通过下方指令即可获取svn服务器仓库中的资源：\n\n``` bash\nsvn co http://hostname/home/svn/repo repo --username peng\n```\n\n### https://\n\n设置同http://，但是需要为Apache2配置支持https的数字证书（略）。\n\n然后通过下方指令即可获取svn服务器仓库中的资源：\n\n``` bash\nsvn co https://hostname/home/svn/repo repo --username peng\n```\n\n## RabbitVCS\n\nRabbitVCS是Linux平台下版本控制程序Subversion的GUI前端客户端，使用Python构建，可以与文件管理器Nautilus紧密整合，支持 Subversion(SVN), Git。可替代Windows下的TortoiseSVN。\n\nUbuntu用户安装:\n``` bash\nsudo add-apt-repository ppa:rabbitvcs/ppa\nsudo apt-get update\nsudo apt-get install rabbitvcs-core rabbitvcs-cli rabbitvcs-nautilus rabbitvcs-gedit\n```\n\n最后输入以下命令重启Nautilus就可以使用RabbitVCS了。\n\n``` bash\nnautilus -q\nnautilus\n```\n\n---\n\n## svn常用命令\n\n以下访问服务器方式均以file:///home/svn/repo为例。\n\n**`import`**: 将项目上传到svn服务器，跟commit对应，是将未版本化的文件导入版本库中的最快方法，它会根据需要创建中介目录。\n\n``` bash\nsvn import myrepo file:///home/svn/repo -m \"Initial import\"\n```\n\n**`export`**: 将项目从服务器导出到本地，跟checkout对应，但是导出的文件夹不含.svn目录，脱离svn版本控制。\n\n``` bash\nsvn export -r version file:///home/svn/repo\n```\n（通过 *`-r version`* 导出指定版本，不加则默认导出最新版本。）\n\n**`checkout`**: 从服务器仓库下载项目到本地，成为本地工作副本。\n``` bash\nsvn checkout file:///home/svn/repo -r version\n或者\nsvn co -r version file:///home/svn/repo\n```\n（通过 *`-r version`* 导出指定版本，不加则默认下载最新版本。）\n\n**`trunk, branches, tags`** 三大目录：\n\n　trunk: 主干，一般把项目提交到此文件夹里面,在trunk中开发。\n　branches: 分支，一般把那些需要打分支,但是有可能会修改的项目代码，打分支到此目录。\n　tags: 分支，一般把那些阶段性(如迭代各期)的项目代码,打分支到此目录。\n\n新建的svn仓库中没有这三个文件夹，可通过下面两种方式创建：\n\n1. 将项目从服务器下载到本地，进入生成的项目目录执行以下代码：\n\n``` bash\nsvn mkdir trunk tags branches\nsvn commit -m　\"Creating trunk, tags, branches\"\n```\n\n2. 如果不想将项目整个下载到本地，也可以直接使用一条命令创建并提交目录到svn服务器：\n\n``` bash\nsvn mkdir file:///home/svn/repo/trunk -m \"Creating trunk dir\"\n```\n\n另外两个目录使用同样的方式进行创建并提交。\n\n**`status`**: 查看工作副本状态。\n\n``` bash\nsvn status\n```\n\n第一列表示文件的状态：\n　，没有修订\n　A，添加\n　C，冲突，需要解决冲突状态，才能正常提交代码\n　D，删除\n　I，忽略\n　M，有修改\n　?，没有版本控制，在工作副本添加文件或目录之后，需要使用svn add your_path才能加该文件加到版本控制\n　!，文件丢失，如果不是使用svn delete删除文件或目录，会产生此状态\n\n**`info`**: 查看工作副本信息。\n\n``` bash\nsvn info\n```\n能够查看到本工作副本的url、版本等信息。\n\n**`update`**: 升级到新版本。\n\n``` bash\nsvn update -r verison\n```\n\n**`add`**: 添加新文件或者目录到版本控制。\n\n``` bash\nsvn add file\nsvn add dir\n```\n\n**`delete`**: 删除文件或目录。\n\n``` bash\nsvn delete file\nsvn delete dir\n```\n如果仅仅是手动使用rm命令或窗口下删除工作副本内的文件或目录，该删除并不会记录svn的状态。可能会导致提交代码时，遗漏了删除文件或目录。因此建议删除svn工作副本内的文件或目录时，使用本命令进行操作。\n\n**`commit`**: 提交代码。\n\n``` bash\nsvn commit [-m message] [file_list]\n```\n如果没有带文件列表，默认把工作副本的所有修订都提交，如果有带文件列表，则只提交文件列表中对应文件的修订。\n\n**`merge`**: 合并代码。\n\n``` bash\nsvn merge -r ver1:ver2 src_url working_copy_path\n```\n可将任意版本的任意修订合并到工作副本中。如果ver1小于ver2，表示合并src_url分支ver1到ver2的修订到本地工作副本；如果ver1大于ver2，表示回退修订。\n\n**`revert`**: 回退工作副本的修订。\n``` bash\nsvn revert file\nsvn revert -R dir\n```\n\n**`log`**: 查看版本log。\n\n``` bash\nsvn log [OPTIONS] [FILE_LIST]\n```\n默认只查看工作副本及以前版本的log，可以使用参数过滤得到我们想要的内容，详情请见 *`svn log --help`* 。\n\n---\n\n## 参考\n\n1. [Subversion](https://help.ubuntu.com/community/Subversion)\n2. [SVN基础用法](https://www.jianshu.com/p/0a8cf8bcdacc)\n3. [Ubuntu搭建svn服务器](https://www.jianshu.com/p/6b83b6f2cace)\n4. [Linux搭建SVN服务器，并设置开机默认启动](http://ourjs.com/detail/5b1ca77b7ad90c6e47f34b72)\n","source":"_posts/svn.md","raw":"---\ntitle: svn的安裝与使用\ndate: 2020-08-03 23:55:05\ntags:\n- svn\n- tutorial\ncategories:\n- [版本控制（git svn）]\n---\n\n本文介绍如何在ubuntu上的搭建svn服务器以及如何使用svn。\n\n<!-- more -->\n\n\n## 安装svn服务器软件subversion\nubuntu系统不自带svn，需要自己安装：\n\n``` bash\nsudo apt-get install subversion\n```\n\n## 创建svn目录\n在home下创建svn文件夹：\n\n``` bash\nsudo mkdir /home/svn\n```\n\n在新创建的svn文件夹下创建repo文件夹（svn的版本仓库存放目录）：\n\n``` bash\nsudo mkdir /home/svn/repo\n```\n\n## 创建svn版本仓库\n\n``` bash\nsudo svnadmin create /home/svn/repo\n```\n\n## 配置svn服务器\n\n创建svn用户组：\n\n``` bash\nsudo addgroup subversion\n```\n\n将自己（比如：peng）加入到svn用户组：\n\n``` bash\nsudo usermod -a -G subversion peng\n```\n\n更改权限：\n\n``` bash\nsudo chown -R peng:subversion /home/svn/repo\nsudo chmod -R g+rws /home/svn/repo\n```\n\n## 访问svn服务器\n访问svn服务器有以下几种协议，下面会一一介绍：\n<table>\n  <tr>\n    <th>协议</th>\n    <th>方式</th>\n  </tr>\n  <tr>\n    <td>file://　</td>\n    <td>直接访问（在相同主机上)</td>\n  </tr>\n  <tr>\n    <td>svn://</td>\n    <td>通过svn用户协议访问</td>\n  </tr>\n  <tr>\n    <td>svn+ssh://</td>\n    <td>和svn://相同，只是通过ssh隧道</td>\n  </tr>\n  <tr>\n    <td>http:// </td>\n    <td>通过WebDAV协议访问subversion支持的Apache 2 web服务器</td>\n  </tr>\n　　<tr>\n    <td>https://</td>\n    <td>和http://次相同，只是用了SSL加密</td>\n  </tr>\n</table>\n\n### file://\n\n不需要做任何设置，直接通过下方指令即可获取本地svn服务器仓库中的资源：\n\n``` bash\nsvn co file:///home/svn/repo\n或者\nsvn co file://localhost/home/svn/repo\n```\n\n### svn://\n\n需要配置/home/svn/repo/conf目录中的文件。\n\n1. svnserve.conf: 服务配置文件：\n\n``` bash\n#匿名用户不可读\nanon-access = none\n#权限用户可写\nauth-access = write\n#密码文件为passwd\npassword-db = passwd\n#权限文件为authz\nauthz-db = authz\n```\n\n2. authz: 用户权限配置文件：\n\n``` bash\n[groups]\nsubversion = peng # subversion组的用户\n\n[/] # 必须写/，因为这表示从仓库的目录开始设置权限\n@subversion = rw # subversion组有rw(读写权限)\n* = r # 所有人有r(读权限)\n```\n\n3. passwd: 用户密码配置文件：\n\n``` bash\n[users]\n # harry = harryssecret\n # sally = sallyssecret\npeng = 12345 # 设定用户peng的密码是12345，是的没错，密码是明文的。\n```\n\n启动svn服务器：\n\n``` bash\nsvnserve -d -r /home/svn/repo\n```\n(-d: 表示在守护模式运行，-r: 指定服务器的根目录)\n默认端口为3690，可以根据需要自行更改或者做些其它设置，详情请见`svnserve --help`。\n\n停止svn服务器：\n\n``` bash\nkillall svnserve\n```\n\n开机默认启动：\n\n可以添加一个自动启动脚本`/etc/init.d/subversion`，设置 svn 服务开机默认启动。\n\n``` bash\n#!/bin/sh\n\n# start/stop subversion daemon\n\ntest -f /usr/bin/svnserve || exit 0\n\nOPTIONS=\"-d -T -r /home/svn/repo\"\n\ncase \"$1\" in\n start)\n  echo -n \"Starting subversion daemon:\"\n  echo -n \" svnserve\"\n  start-stop-daemon --start --quiet --oknodo --chuid root:root --exec /usr/bin/svnserve -- $OPTIONS\n  echo \".\"\n  ;;\n\n stop)\n  echo -n \"Stopping subversion daemon:\"\n  echo -n \" svnserve\"\n  start-stop-daemon --stop --quiet --oknodo --exec /usr/bin/svnserve\n  echo \".\"\n  ;;\n\n reload)\n  ;;\n\n force-reload)\n  $0 restart\n  ;;\n\n restart)\n  $0 stop\n  $0 start\n  ;;\n\n *)\n  echo \"Usage: /etc/init.d/subversion (start|stop|reload|restart)\"\n  exit 1\n  ;;\n\nesac\n\nexit 0\n```\n\n添加执行权限：\n\n``` bash\nsudo chmod u+x /etc/init.d/subversion\n```\n\n测试一下从脚本启动：\n\n``` bash\nsudo /etc/init.d/subversion start\n```\n\n将此脚本设置为开机默认启动：\n\n``` bash\nsudo update-rc.d -f subversion defaults\n```\n\n在svnserve已开启的情况下，通过下方指令获取svn服务器仓库中的资源：\n\n``` bash\nsvn co svn://hostname repo --username peng\n```\n\n### svn+ssh://\n\n设置同svn://，在ssh服务已经打开的情况下，通过下方指令即可获取svn服务器仓库中的资源：\n\n``` bash\nsvn co svn+ssh://hostname/home/svn/repo repo --username peng\n```\n\n注意：这里必须加上仓库的完整路径（/home/svn/repo）, 而svn://方式则不用。\n\n\n### http://\n\n需要安装并配置Apache2 web server。\n\n安装Apache2：\n\n``` bash\nsudo apt-get install apache2\n```\n\n配置Apache2：\n\n在`etc/apache2/mods_available/dav_svn.conf`文件中添加以下代码：\n\n``` bash\n<Location /home/svn/repo>\n    DAV svn\n    SVNPath /home/svn/repo\n    AuthType Basic\n    AuthName \"subversion repository\"\n    AuthUserFile /etc/subversion/passwd\n    Require valid-user\n</Location>\n```\n\n添加Apache2用户www-data并加入到subversion组中：\n\n``` bash\nsudo adduser www-data subversion\n```\n\n重启Apache2服务：\n\n``` bash\nsudo /etc/init.d/apache2 restart\n```\n\n创建用户和密码文件（`/etc/subversion/passwd`）：\n\n``` bash\nsudo htpasswd -c /etc/subversion/passwd peng\n```\n按照提示输入密码即可。\n通过下面的命令可添加新用户（new_user）：\n``` bash\nsudo htpasswd /etc/subversion/passwd new_user\n```\n\n配置完成，通过下方指令即可获取svn服务器仓库中的资源：\n\n``` bash\nsvn co http://hostname/home/svn/repo repo --username peng\n```\n\n### https://\n\n设置同http://，但是需要为Apache2配置支持https的数字证书（略）。\n\n然后通过下方指令即可获取svn服务器仓库中的资源：\n\n``` bash\nsvn co https://hostname/home/svn/repo repo --username peng\n```\n\n## RabbitVCS\n\nRabbitVCS是Linux平台下版本控制程序Subversion的GUI前端客户端，使用Python构建，可以与文件管理器Nautilus紧密整合，支持 Subversion(SVN), Git。可替代Windows下的TortoiseSVN。\n\nUbuntu用户安装:\n``` bash\nsudo add-apt-repository ppa:rabbitvcs/ppa\nsudo apt-get update\nsudo apt-get install rabbitvcs-core rabbitvcs-cli rabbitvcs-nautilus rabbitvcs-gedit\n```\n\n最后输入以下命令重启Nautilus就可以使用RabbitVCS了。\n\n``` bash\nnautilus -q\nnautilus\n```\n\n---\n\n## svn常用命令\n\n以下访问服务器方式均以file:///home/svn/repo为例。\n\n**`import`**: 将项目上传到svn服务器，跟commit对应，是将未版本化的文件导入版本库中的最快方法，它会根据需要创建中介目录。\n\n``` bash\nsvn import myrepo file:///home/svn/repo -m \"Initial import\"\n```\n\n**`export`**: 将项目从服务器导出到本地，跟checkout对应，但是导出的文件夹不含.svn目录，脱离svn版本控制。\n\n``` bash\nsvn export -r version file:///home/svn/repo\n```\n（通过 *`-r version`* 导出指定版本，不加则默认导出最新版本。）\n\n**`checkout`**: 从服务器仓库下载项目到本地，成为本地工作副本。\n``` bash\nsvn checkout file:///home/svn/repo -r version\n或者\nsvn co -r version file:///home/svn/repo\n```\n（通过 *`-r version`* 导出指定版本，不加则默认下载最新版本。）\n\n**`trunk, branches, tags`** 三大目录：\n\n　trunk: 主干，一般把项目提交到此文件夹里面,在trunk中开发。\n　branches: 分支，一般把那些需要打分支,但是有可能会修改的项目代码，打分支到此目录。\n　tags: 分支，一般把那些阶段性(如迭代各期)的项目代码,打分支到此目录。\n\n新建的svn仓库中没有这三个文件夹，可通过下面两种方式创建：\n\n1. 将项目从服务器下载到本地，进入生成的项目目录执行以下代码：\n\n``` bash\nsvn mkdir trunk tags branches\nsvn commit -m　\"Creating trunk, tags, branches\"\n```\n\n2. 如果不想将项目整个下载到本地，也可以直接使用一条命令创建并提交目录到svn服务器：\n\n``` bash\nsvn mkdir file:///home/svn/repo/trunk -m \"Creating trunk dir\"\n```\n\n另外两个目录使用同样的方式进行创建并提交。\n\n**`status`**: 查看工作副本状态。\n\n``` bash\nsvn status\n```\n\n第一列表示文件的状态：\n　，没有修订\n　A，添加\n　C，冲突，需要解决冲突状态，才能正常提交代码\n　D，删除\n　I，忽略\n　M，有修改\n　?，没有版本控制，在工作副本添加文件或目录之后，需要使用svn add your_path才能加该文件加到版本控制\n　!，文件丢失，如果不是使用svn delete删除文件或目录，会产生此状态\n\n**`info`**: 查看工作副本信息。\n\n``` bash\nsvn info\n```\n能够查看到本工作副本的url、版本等信息。\n\n**`update`**: 升级到新版本。\n\n``` bash\nsvn update -r verison\n```\n\n**`add`**: 添加新文件或者目录到版本控制。\n\n``` bash\nsvn add file\nsvn add dir\n```\n\n**`delete`**: 删除文件或目录。\n\n``` bash\nsvn delete file\nsvn delete dir\n```\n如果仅仅是手动使用rm命令或窗口下删除工作副本内的文件或目录，该删除并不会记录svn的状态。可能会导致提交代码时，遗漏了删除文件或目录。因此建议删除svn工作副本内的文件或目录时，使用本命令进行操作。\n\n**`commit`**: 提交代码。\n\n``` bash\nsvn commit [-m message] [file_list]\n```\n如果没有带文件列表，默认把工作副本的所有修订都提交，如果有带文件列表，则只提交文件列表中对应文件的修订。\n\n**`merge`**: 合并代码。\n\n``` bash\nsvn merge -r ver1:ver2 src_url working_copy_path\n```\n可将任意版本的任意修订合并到工作副本中。如果ver1小于ver2，表示合并src_url分支ver1到ver2的修订到本地工作副本；如果ver1大于ver2，表示回退修订。\n\n**`revert`**: 回退工作副本的修订。\n``` bash\nsvn revert file\nsvn revert -R dir\n```\n\n**`log`**: 查看版本log。\n\n``` bash\nsvn log [OPTIONS] [FILE_LIST]\n```\n默认只查看工作副本及以前版本的log，可以使用参数过滤得到我们想要的内容，详情请见 *`svn log --help`* 。\n\n---\n\n## 参考\n\n1. [Subversion](https://help.ubuntu.com/community/Subversion)\n2. [SVN基础用法](https://www.jianshu.com/p/0a8cf8bcdacc)\n3. [Ubuntu搭建svn服务器](https://www.jianshu.com/p/6b83b6f2cace)\n4. [Linux搭建SVN服务器，并设置开机默认启动](http://ourjs.com/detail/5b1ca77b7ad90c6e47f34b72)\n","slug":"svn","published":1,"updated":"2020-08-07T10:02:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdypyf71000dm4k2hoi5da99","content":"<p>本文介绍如何在ubuntu上的搭建svn服务器以及如何使用svn。</p>\n<a id=\"more\"></a>\n<h2 id=\"安装svn服务器软件subversion\"><a href=\"#安装svn服务器软件subversion\" class=\"headerlink\" title=\"安装svn服务器软件subversion\"></a>安装svn服务器软件subversion</h2><p>ubuntu系统不自带svn，需要自己安装：</p>\n<pre><code class=\"hljs bash\">sudo apt-get install subversion</code></pre>\n<h2 id=\"创建svn目录\"><a href=\"#创建svn目录\" class=\"headerlink\" title=\"创建svn目录\"></a>创建svn目录</h2><p>在home下创建svn文件夹：</p>\n<pre><code class=\"hljs bash\">sudo mkdir /home/svn</code></pre>\n<p>在新创建的svn文件夹下创建repo文件夹（svn的版本仓库存放目录）：</p>\n<pre><code class=\"hljs bash\">sudo mkdir /home/svn/repo</code></pre>\n<h2 id=\"创建svn版本仓库\"><a href=\"#创建svn版本仓库\" class=\"headerlink\" title=\"创建svn版本仓库\"></a>创建svn版本仓库</h2><pre><code class=\"hljs bash\">sudo svnadmin create /home/svn/repo</code></pre>\n<h2 id=\"配置svn服务器\"><a href=\"#配置svn服务器\" class=\"headerlink\" title=\"配置svn服务器\"></a>配置svn服务器</h2><p>创建svn用户组：</p>\n<pre><code class=\"hljs bash\">sudo addgroup subversion</code></pre>\n<p>将自己（比如：peng）加入到svn用户组：</p>\n<pre><code class=\"hljs bash\">sudo usermod -a -G subversion peng</code></pre>\n<p>更改权限：</p>\n<pre><code class=\"hljs bash\">sudo chown -R peng:subversion /home/svn/repo\nsudo chmod -R g+rws /home/svn/repo</code></pre>\n<h2 id=\"访问svn服务器\"><a href=\"#访问svn服务器\" class=\"headerlink\" title=\"访问svn服务器\"></a>访问svn服务器</h2><p>访问svn服务器有以下几种协议，下面会一一介绍：</p>\n<table><br>  <tr><br>    <th>协议</th><br>    <th>方式</th><br>  </tr><br>  <tr><br>    <td>file://　</td><br>    <td>直接访问（在相同主机上)</td><br>  </tr><br>  <tr><br>    <td>svn://</td><br>    <td>通过svn用户协议访问</td><br>  </tr><br>  <tr><br>    <td>svn+ssh://</td><br>    <td>和svn://相同，只是通过ssh隧道</td><br>  </tr><br>  <tr><br>    <td>http:// </td><br>    <td>通过WebDAV协议访问subversion支持的Apache 2 web服务器</td><br>  </tr><br>　　<tr><br>    <td>https://</td><br>    <td>和http://次相同，只是用了SSL加密</td><br>  </tr><br></table>\n\n<h3 id=\"file\"><a href=\"#file\" class=\"headerlink\" title=\"file://\"></a>file://</h3><p>不需要做任何设置，直接通过下方指令即可获取本地svn服务器仓库中的资源：</p>\n<pre><code class=\"hljs bash\">svn co file:///home/svn/repo\n或者\nsvn co file://localhost/home/svn/repo</code></pre>\n<h3 id=\"svn\"><a href=\"#svn\" class=\"headerlink\" title=\"svn://\"></a>svn://</h3><p>需要配置/home/svn/repo/conf目录中的文件。</p>\n<ol>\n<li>svnserve.conf: 服务配置文件：</li>\n</ol>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#匿名用户不可读</span>\nanon-access = none\n<span class=\"hljs-comment\">#权限用户可写</span>\nauth-access = write\n<span class=\"hljs-comment\">#密码文件为passwd</span>\npassword-db = passwd\n<span class=\"hljs-comment\">#权限文件为authz</span>\nauthz-db = authz</code></pre>\n<ol start=\"2\">\n<li>authz: 用户权限配置文件：</li>\n</ol>\n<pre><code class=\"hljs bash\">[groups]\nsubversion = peng <span class=\"hljs-comment\"># subversion组的用户</span>\n\n[/] <span class=\"hljs-comment\"># 必须写/，因为这表示从仓库的目录开始设置权限</span>\n@subversion = rw <span class=\"hljs-comment\"># subversion组有rw(读写权限)</span>\n* = r <span class=\"hljs-comment\"># 所有人有r(读权限)</span></code></pre>\n<ol start=\"3\">\n<li>passwd: 用户密码配置文件：</li>\n</ol>\n<pre><code class=\"hljs bash\">[users]\n <span class=\"hljs-comment\"># harry = harryssecret</span>\n <span class=\"hljs-comment\"># sally = sallyssecret</span>\npeng = 12345 <span class=\"hljs-comment\"># 设定用户peng的密码是12345，是的没错，密码是明文的。</span></code></pre>\n<p>启动svn服务器：</p>\n<pre><code class=\"hljs bash\">svnserve -d -r /home/svn/repo</code></pre>\n<p>(-d: 表示在守护模式运行，-r: 指定服务器的根目录)<br>默认端口为3690，可以根据需要自行更改或者做些其它设置，详情请见<code>svnserve --help</code>。</p>\n<p>停止svn服务器：</p>\n<pre><code class=\"hljs bash\">killall svnserve</code></pre>\n<p>开机默认启动：</p>\n<p>可以添加一个自动启动脚本<code>/etc/init.d/subversion</code>，设置 svn 服务开机默认启动。</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-meta\">#!/bin/sh</span>\n\n<span class=\"hljs-comment\"># start/stop subversion daemon</span>\n\n<span class=\"hljs-built_in\">test</span> -f /usr/bin/svnserve || <span class=\"hljs-built_in\">exit</span> 0\n\nOPTIONS=<span class=\"hljs-string\">&quot;-d -T -r /home/svn/repo&quot;</span>\n\n<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$1</span>&quot;</span> <span class=\"hljs-keyword\">in</span>\n start)\n  <span class=\"hljs-built_in\">echo</span> -n <span class=\"hljs-string\">&quot;Starting subversion daemon:&quot;</span>\n  <span class=\"hljs-built_in\">echo</span> -n <span class=\"hljs-string\">&quot; svnserve&quot;</span>\n  start-stop-daemon --start --quiet --oknodo --chuid root:root --<span class=\"hljs-built_in\">exec</span> /usr/bin/svnserve -- <span class=\"hljs-variable\">$OPTIONS</span>\n  <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;.&quot;</span>\n  ;;\n\n stop)\n  <span class=\"hljs-built_in\">echo</span> -n <span class=\"hljs-string\">&quot;Stopping subversion daemon:&quot;</span>\n  <span class=\"hljs-built_in\">echo</span> -n <span class=\"hljs-string\">&quot; svnserve&quot;</span>\n  start-stop-daemon --stop --quiet --oknodo --<span class=\"hljs-built_in\">exec</span> /usr/bin/svnserve\n  <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;.&quot;</span>\n  ;;\n\n reload)\n  ;;\n\n force-reload)\n  <span class=\"hljs-variable\">$0</span> restart\n  ;;\n\n restart)\n  <span class=\"hljs-variable\">$0</span> stop\n  <span class=\"hljs-variable\">$0</span> start\n  ;;\n\n *)\n  <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Usage: /etc/init.d/subversion (start|stop|reload|restart)&quot;</span>\n  <span class=\"hljs-built_in\">exit</span> 1\n  ;;\n\n<span class=\"hljs-keyword\">esac</span>\n\n<span class=\"hljs-built_in\">exit</span> 0</code></pre>\n<p>添加执行权限：</p>\n<pre><code class=\"hljs bash\">sudo chmod u+x /etc/init.d/subversion</code></pre>\n<p>测试一下从脚本启动：</p>\n<pre><code class=\"hljs bash\">sudo /etc/init.d/subversion start</code></pre>\n<p>将此脚本设置为开机默认启动：</p>\n<pre><code class=\"hljs bash\">sudo update-rc.d -f subversion defaults</code></pre>\n<p>在svnserve已开启的情况下，通过下方指令获取svn服务器仓库中的资源：</p>\n<pre><code class=\"hljs bash\">svn co svn://hostname repo --username peng</code></pre>\n<h3 id=\"svn-ssh\"><a href=\"#svn-ssh\" class=\"headerlink\" title=\"svn+ssh://\"></a>svn+ssh://</h3><p>设置同svn://，在ssh服务已经打开的情况下，通过下方指令即可获取svn服务器仓库中的资源：</p>\n<pre><code class=\"hljs bash\">svn co svn+ssh://hostname/home/svn/repo repo --username peng</code></pre>\n<p>注意：这里必须加上仓库的完整路径（/home/svn/repo）, 而svn://方式则不用。</p>\n<h3 id=\"http\"><a href=\"#http\" class=\"headerlink\" title=\"http://\"></a>http://</h3><p>需要安装并配置Apache2 web server。</p>\n<p>安装Apache2：</p>\n<pre><code class=\"hljs bash\">sudo apt-get install apache2</code></pre>\n<p>配置Apache2：</p>\n<p>在<code>etc/apache2/mods_available/dav_svn.conf</code>文件中添加以下代码：</p>\n<pre><code class=\"hljs bash\">&lt;Location /home/svn/repo&gt;\n    DAV svn\n    SVNPath /home/svn/repo\n    AuthType Basic\n    AuthName <span class=\"hljs-string\">&quot;subversion repository&quot;</span>\n    AuthUserFile /etc/subversion/passwd\n    Require valid-user\n&lt;/Location&gt;</code></pre>\n<p>添加Apache2用户www-data并加入到subversion组中：</p>\n<pre><code class=\"hljs bash\">sudo adduser www-data subversion</code></pre>\n<p>重启Apache2服务：</p>\n<pre><code class=\"hljs bash\">sudo /etc/init.d/apache2 restart</code></pre>\n<p>创建用户和密码文件（<code>/etc/subversion/passwd</code>）：</p>\n<pre><code class=\"hljs bash\">sudo htpasswd -c /etc/subversion/passwd peng</code></pre>\n<p>按照提示输入密码即可。<br>通过下面的命令可添加新用户（new_user）：<br><pre><code class=\"hljs bash\">sudo htpasswd /etc/subversion/passwd new_user</code></pre></p>\n<p>配置完成，通过下方指令即可获取svn服务器仓库中的资源：</p>\n<pre><code class=\"hljs bash\">svn co http://hostname/home/svn/repo repo --username peng</code></pre>\n<h3 id=\"https\"><a href=\"#https\" class=\"headerlink\" title=\"https://\"></a>https://</h3><p>设置同http://，但是需要为Apache2配置支持https的数字证书（略）。</p>\n<p>然后通过下方指令即可获取svn服务器仓库中的资源：</p>\n<pre><code class=\"hljs bash\">svn co https://hostname/home/svn/repo repo --username peng</code></pre>\n<h2 id=\"RabbitVCS\"><a href=\"#RabbitVCS\" class=\"headerlink\" title=\"RabbitVCS\"></a>RabbitVCS</h2><p>RabbitVCS是Linux平台下版本控制程序Subversion的GUI前端客户端，使用Python构建，可以与文件管理器Nautilus紧密整合，支持 Subversion(SVN), Git。可替代Windows下的TortoiseSVN。</p>\n<p>Ubuntu用户安装:<br><pre><code class=\"hljs bash\">sudo add-apt-repository ppa:rabbitvcs/ppa\nsudo apt-get update\nsudo apt-get install rabbitvcs-core rabbitvcs-cli rabbitvcs-nautilus rabbitvcs-gedit</code></pre></p>\n<p>最后输入以下命令重启Nautilus就可以使用RabbitVCS了。</p>\n<pre><code class=\"hljs bash\">nautilus -q\nnautilus</code></pre>\n<hr>\n<h2 id=\"svn常用命令\"><a href=\"#svn常用命令\" class=\"headerlink\" title=\"svn常用命令\"></a>svn常用命令</h2><p>以下访问服务器方式均以file:///home/svn/repo为例。</p>\n<p><strong><code>import</code></strong>: 将项目上传到svn服务器，跟commit对应，是将未版本化的文件导入版本库中的最快方法，它会根据需要创建中介目录。</p>\n<pre><code class=\"hljs bash\">svn import myrepo file:///home/svn/repo -m <span class=\"hljs-string\">&quot;Initial import&quot;</span></code></pre>\n<p><strong><code>export</code></strong>: 将项目从服务器导出到本地，跟checkout对应，但是导出的文件夹不含.svn目录，脱离svn版本控制。</p>\n<pre><code class=\"hljs bash\">svn <span class=\"hljs-built_in\">export</span> -r version file:///home/svn/repo</code></pre>\n<p>（通过 <em><code>-r version</code></em> 导出指定版本，不加则默认导出最新版本。）</p>\n<p><strong><code>checkout</code></strong>: 从服务器仓库下载项目到本地，成为本地工作副本。<br><pre><code class=\"hljs bash\">svn checkout file:///home/svn/repo -r version\n或者\nsvn co -r version file:///home/svn/repo</code></pre><br>（通过 <em><code>-r version</code></em> 导出指定版本，不加则默认下载最新版本。）</p>\n<p><strong><code>trunk, branches, tags</code></strong> 三大目录：</p>\n<p>　trunk: 主干，一般把项目提交到此文件夹里面,在trunk中开发。<br>　branches: 分支，一般把那些需要打分支,但是有可能会修改的项目代码，打分支到此目录。<br>　tags: 分支，一般把那些阶段性(如迭代各期)的项目代码,打分支到此目录。</p>\n<p>新建的svn仓库中没有这三个文件夹，可通过下面两种方式创建：</p>\n<ol>\n<li>将项目从服务器下载到本地，进入生成的项目目录执行以下代码：</li>\n</ol>\n<pre><code class=\"hljs bash\">svn mkdir trunk tags branches\nsvn commit -m　<span class=\"hljs-string\">&quot;Creating trunk, tags, branches&quot;</span></code></pre>\n<ol start=\"2\">\n<li>如果不想将项目整个下载到本地，也可以直接使用一条命令创建并提交目录到svn服务器：</li>\n</ol>\n<pre><code class=\"hljs bash\">svn mkdir file:///home/svn/repo/trunk -m <span class=\"hljs-string\">&quot;Creating trunk dir&quot;</span></code></pre>\n<p>另外两个目录使用同样的方式进行创建并提交。</p>\n<p><strong><code>status</code></strong>: 查看工作副本状态。</p>\n<pre><code class=\"hljs bash\">svn status</code></pre>\n<p>第一列表示文件的状态：<br>　，没有修订<br>　A，添加<br>　C，冲突，需要解决冲突状态，才能正常提交代码<br>　D，删除<br>　I，忽略<br>　M，有修改<br>　?，没有版本控制，在工作副本添加文件或目录之后，需要使用svn add your_path才能加该文件加到版本控制<br>　!，文件丢失，如果不是使用svn delete删除文件或目录，会产生此状态</p>\n<p><strong><code>info</code></strong>: 查看工作副本信息。</p>\n<pre><code class=\"hljs bash\">svn info</code></pre>\n<p>能够查看到本工作副本的url、版本等信息。</p>\n<p><strong><code>update</code></strong>: 升级到新版本。</p>\n<pre><code class=\"hljs bash\">svn update -r verison</code></pre>\n<p><strong><code>add</code></strong>: 添加新文件或者目录到版本控制。</p>\n<pre><code class=\"hljs bash\">svn add file\nsvn add dir</code></pre>\n<p><strong><code>delete</code></strong>: 删除文件或目录。</p>\n<pre><code class=\"hljs bash\">svn delete file\nsvn delete dir</code></pre>\n<p>如果仅仅是手动使用rm命令或窗口下删除工作副本内的文件或目录，该删除并不会记录svn的状态。可能会导致提交代码时，遗漏了删除文件或目录。因此建议删除svn工作副本内的文件或目录时，使用本命令进行操作。</p>\n<p><strong><code>commit</code></strong>: 提交代码。</p>\n<pre><code class=\"hljs bash\">svn commit [-m message] [file_list]</code></pre>\n<p>如果没有带文件列表，默认把工作副本的所有修订都提交，如果有带文件列表，则只提交文件列表中对应文件的修订。</p>\n<p><strong><code>merge</code></strong>: 合并代码。</p>\n<pre><code class=\"hljs bash\">svn merge -r ver1:ver2 src_url working_copy_path</code></pre>\n<p>可将任意版本的任意修订合并到工作副本中。如果ver1小于ver2，表示合并src_url分支ver1到ver2的修订到本地工作副本；如果ver1大于ver2，表示回退修订。</p>\n<p><strong><code>revert</code></strong>: 回退工作副本的修订。<br><pre><code class=\"hljs bash\">svn revert file\nsvn revert -R dir</code></pre></p>\n<p><strong><code>log</code></strong>: 查看版本log。</p>\n<pre><code class=\"hljs bash\">svn <span class=\"hljs-built_in\">log</span> [OPTIONS] [FILE_LIST]</code></pre>\n<p>默认只查看工作副本及以前版本的log，可以使用参数过滤得到我们想要的内容，详情请见 <em><code>svn log --help</code></em> 。</p>\n<hr>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://help.ubuntu.com/community/Subversion\">Subversion</a></li>\n<li><a href=\"https://www.jianshu.com/p/0a8cf8bcdacc\">SVN基础用法</a></li>\n<li><a href=\"https://www.jianshu.com/p/6b83b6f2cace\">Ubuntu搭建svn服务器</a></li>\n<li><a href=\"http://ourjs.com/detail/5b1ca77b7ad90c6e47f34b72\">Linux搭建SVN服务器，并设置开机默认启动</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>本文介绍如何在ubuntu上的搭建svn服务器以及如何使用svn。</p>","more":"<h2 id=\"安装svn服务器软件subversion\"><a href=\"#安装svn服务器软件subversion\" class=\"headerlink\" title=\"安装svn服务器软件subversion\"></a>安装svn服务器软件subversion</h2><p>ubuntu系统不自带svn，需要自己安装：</p>\n<pre><code class=\"hljs bash\">sudo apt-get install subversion</code></pre>\n<h2 id=\"创建svn目录\"><a href=\"#创建svn目录\" class=\"headerlink\" title=\"创建svn目录\"></a>创建svn目录</h2><p>在home下创建svn文件夹：</p>\n<pre><code class=\"hljs bash\">sudo mkdir /home/svn</code></pre>\n<p>在新创建的svn文件夹下创建repo文件夹（svn的版本仓库存放目录）：</p>\n<pre><code class=\"hljs bash\">sudo mkdir /home/svn/repo</code></pre>\n<h2 id=\"创建svn版本仓库\"><a href=\"#创建svn版本仓库\" class=\"headerlink\" title=\"创建svn版本仓库\"></a>创建svn版本仓库</h2><pre><code class=\"hljs bash\">sudo svnadmin create /home/svn/repo</code></pre>\n<h2 id=\"配置svn服务器\"><a href=\"#配置svn服务器\" class=\"headerlink\" title=\"配置svn服务器\"></a>配置svn服务器</h2><p>创建svn用户组：</p>\n<pre><code class=\"hljs bash\">sudo addgroup subversion</code></pre>\n<p>将自己（比如：peng）加入到svn用户组：</p>\n<pre><code class=\"hljs bash\">sudo usermod -a -G subversion peng</code></pre>\n<p>更改权限：</p>\n<pre><code class=\"hljs bash\">sudo chown -R peng:subversion /home/svn/repo\nsudo chmod -R g+rws /home/svn/repo</code></pre>\n<h2 id=\"访问svn服务器\"><a href=\"#访问svn服务器\" class=\"headerlink\" title=\"访问svn服务器\"></a>访问svn服务器</h2><p>访问svn服务器有以下几种协议，下面会一一介绍：</p>\n<table><br>  <tr><br>    <th>协议</th><br>    <th>方式</th><br>  </tr><br>  <tr><br>    <td>file://　</td><br>    <td>直接访问（在相同主机上)</td><br>  </tr><br>  <tr><br>    <td>svn://</td><br>    <td>通过svn用户协议访问</td><br>  </tr><br>  <tr><br>    <td>svn+ssh://</td><br>    <td>和svn://相同，只是通过ssh隧道</td><br>  </tr><br>  <tr><br>    <td>http:// </td><br>    <td>通过WebDAV协议访问subversion支持的Apache 2 web服务器</td><br>  </tr><br>　　<tr><br>    <td>https://</td><br>    <td>和http://次相同，只是用了SSL加密</td><br>  </tr><br></table>\n\n<h3 id=\"file\"><a href=\"#file\" class=\"headerlink\" title=\"file://\"></a>file://</h3><p>不需要做任何设置，直接通过下方指令即可获取本地svn服务器仓库中的资源：</p>\n<pre><code class=\"hljs bash\">svn co file:///home/svn/repo\n或者\nsvn co file://localhost/home/svn/repo</code></pre>\n<h3 id=\"svn\"><a href=\"#svn\" class=\"headerlink\" title=\"svn://\"></a>svn://</h3><p>需要配置/home/svn/repo/conf目录中的文件。</p>\n<ol>\n<li>svnserve.conf: 服务配置文件：</li>\n</ol>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#匿名用户不可读</span>\nanon-access = none\n<span class=\"hljs-comment\">#权限用户可写</span>\nauth-access = write\n<span class=\"hljs-comment\">#密码文件为passwd</span>\npassword-db = passwd\n<span class=\"hljs-comment\">#权限文件为authz</span>\nauthz-db = authz</code></pre>\n<ol start=\"2\">\n<li>authz: 用户权限配置文件：</li>\n</ol>\n<pre><code class=\"hljs bash\">[groups]\nsubversion = peng <span class=\"hljs-comment\"># subversion组的用户</span>\n\n[/] <span class=\"hljs-comment\"># 必须写/，因为这表示从仓库的目录开始设置权限</span>\n@subversion = rw <span class=\"hljs-comment\"># subversion组有rw(读写权限)</span>\n* = r <span class=\"hljs-comment\"># 所有人有r(读权限)</span></code></pre>\n<ol start=\"3\">\n<li>passwd: 用户密码配置文件：</li>\n</ol>\n<pre><code class=\"hljs bash\">[users]\n <span class=\"hljs-comment\"># harry = harryssecret</span>\n <span class=\"hljs-comment\"># sally = sallyssecret</span>\npeng = 12345 <span class=\"hljs-comment\"># 设定用户peng的密码是12345，是的没错，密码是明文的。</span></code></pre>\n<p>启动svn服务器：</p>\n<pre><code class=\"hljs bash\">svnserve -d -r /home/svn/repo</code></pre>\n<p>(-d: 表示在守护模式运行，-r: 指定服务器的根目录)<br>默认端口为3690，可以根据需要自行更改或者做些其它设置，详情请见<code>svnserve --help</code>。</p>\n<p>停止svn服务器：</p>\n<pre><code class=\"hljs bash\">killall svnserve</code></pre>\n<p>开机默认启动：</p>\n<p>可以添加一个自动启动脚本<code>/etc/init.d/subversion</code>，设置 svn 服务开机默认启动。</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-meta\">#!/bin/sh</span>\n\n<span class=\"hljs-comment\"># start/stop subversion daemon</span>\n\n<span class=\"hljs-built_in\">test</span> -f /usr/bin/svnserve || <span class=\"hljs-built_in\">exit</span> 0\n\nOPTIONS=<span class=\"hljs-string\">&quot;-d -T -r /home/svn/repo&quot;</span>\n\n<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$1</span>&quot;</span> <span class=\"hljs-keyword\">in</span>\n start)\n  <span class=\"hljs-built_in\">echo</span> -n <span class=\"hljs-string\">&quot;Starting subversion daemon:&quot;</span>\n  <span class=\"hljs-built_in\">echo</span> -n <span class=\"hljs-string\">&quot; svnserve&quot;</span>\n  start-stop-daemon --start --quiet --oknodo --chuid root:root --<span class=\"hljs-built_in\">exec</span> /usr/bin/svnserve -- <span class=\"hljs-variable\">$OPTIONS</span>\n  <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;.&quot;</span>\n  ;;\n\n stop)\n  <span class=\"hljs-built_in\">echo</span> -n <span class=\"hljs-string\">&quot;Stopping subversion daemon:&quot;</span>\n  <span class=\"hljs-built_in\">echo</span> -n <span class=\"hljs-string\">&quot; svnserve&quot;</span>\n  start-stop-daemon --stop --quiet --oknodo --<span class=\"hljs-built_in\">exec</span> /usr/bin/svnserve\n  <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;.&quot;</span>\n  ;;\n\n reload)\n  ;;\n\n force-reload)\n  <span class=\"hljs-variable\">$0</span> restart\n  ;;\n\n restart)\n  <span class=\"hljs-variable\">$0</span> stop\n  <span class=\"hljs-variable\">$0</span> start\n  ;;\n\n *)\n  <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Usage: /etc/init.d/subversion (start|stop|reload|restart)&quot;</span>\n  <span class=\"hljs-built_in\">exit</span> 1\n  ;;\n\n<span class=\"hljs-keyword\">esac</span>\n\n<span class=\"hljs-built_in\">exit</span> 0</code></pre>\n<p>添加执行权限：</p>\n<pre><code class=\"hljs bash\">sudo chmod u+x /etc/init.d/subversion</code></pre>\n<p>测试一下从脚本启动：</p>\n<pre><code class=\"hljs bash\">sudo /etc/init.d/subversion start</code></pre>\n<p>将此脚本设置为开机默认启动：</p>\n<pre><code class=\"hljs bash\">sudo update-rc.d -f subversion defaults</code></pre>\n<p>在svnserve已开启的情况下，通过下方指令获取svn服务器仓库中的资源：</p>\n<pre><code class=\"hljs bash\">svn co svn://hostname repo --username peng</code></pre>\n<h3 id=\"svn-ssh\"><a href=\"#svn-ssh\" class=\"headerlink\" title=\"svn+ssh://\"></a>svn+ssh://</h3><p>设置同svn://，在ssh服务已经打开的情况下，通过下方指令即可获取svn服务器仓库中的资源：</p>\n<pre><code class=\"hljs bash\">svn co svn+ssh://hostname/home/svn/repo repo --username peng</code></pre>\n<p>注意：这里必须加上仓库的完整路径（/home/svn/repo）, 而svn://方式则不用。</p>\n<h3 id=\"http\"><a href=\"#http\" class=\"headerlink\" title=\"http://\"></a>http://</h3><p>需要安装并配置Apache2 web server。</p>\n<p>安装Apache2：</p>\n<pre><code class=\"hljs bash\">sudo apt-get install apache2</code></pre>\n<p>配置Apache2：</p>\n<p>在<code>etc/apache2/mods_available/dav_svn.conf</code>文件中添加以下代码：</p>\n<pre><code class=\"hljs bash\">&lt;Location /home/svn/repo&gt;\n    DAV svn\n    SVNPath /home/svn/repo\n    AuthType Basic\n    AuthName <span class=\"hljs-string\">&quot;subversion repository&quot;</span>\n    AuthUserFile /etc/subversion/passwd\n    Require valid-user\n&lt;/Location&gt;</code></pre>\n<p>添加Apache2用户www-data并加入到subversion组中：</p>\n<pre><code class=\"hljs bash\">sudo adduser www-data subversion</code></pre>\n<p>重启Apache2服务：</p>\n<pre><code class=\"hljs bash\">sudo /etc/init.d/apache2 restart</code></pre>\n<p>创建用户和密码文件（<code>/etc/subversion/passwd</code>）：</p>\n<pre><code class=\"hljs bash\">sudo htpasswd -c /etc/subversion/passwd peng</code></pre>\n<p>按照提示输入密码即可。<br>通过下面的命令可添加新用户（new_user）：<br><pre><code class=\"hljs bash\">sudo htpasswd /etc/subversion/passwd new_user</code></pre></p>\n<p>配置完成，通过下方指令即可获取svn服务器仓库中的资源：</p>\n<pre><code class=\"hljs bash\">svn co http://hostname/home/svn/repo repo --username peng</code></pre>\n<h3 id=\"https\"><a href=\"#https\" class=\"headerlink\" title=\"https://\"></a>https://</h3><p>设置同http://，但是需要为Apache2配置支持https的数字证书（略）。</p>\n<p>然后通过下方指令即可获取svn服务器仓库中的资源：</p>\n<pre><code class=\"hljs bash\">svn co https://hostname/home/svn/repo repo --username peng</code></pre>\n<h2 id=\"RabbitVCS\"><a href=\"#RabbitVCS\" class=\"headerlink\" title=\"RabbitVCS\"></a>RabbitVCS</h2><p>RabbitVCS是Linux平台下版本控制程序Subversion的GUI前端客户端，使用Python构建，可以与文件管理器Nautilus紧密整合，支持 Subversion(SVN), Git。可替代Windows下的TortoiseSVN。</p>\n<p>Ubuntu用户安装:<br><pre><code class=\"hljs bash\">sudo add-apt-repository ppa:rabbitvcs/ppa\nsudo apt-get update\nsudo apt-get install rabbitvcs-core rabbitvcs-cli rabbitvcs-nautilus rabbitvcs-gedit</code></pre></p>\n<p>最后输入以下命令重启Nautilus就可以使用RabbitVCS了。</p>\n<pre><code class=\"hljs bash\">nautilus -q\nnautilus</code></pre>\n<hr>\n<h2 id=\"svn常用命令\"><a href=\"#svn常用命令\" class=\"headerlink\" title=\"svn常用命令\"></a>svn常用命令</h2><p>以下访问服务器方式均以file:///home/svn/repo为例。</p>\n<p><strong><code>import</code></strong>: 将项目上传到svn服务器，跟commit对应，是将未版本化的文件导入版本库中的最快方法，它会根据需要创建中介目录。</p>\n<pre><code class=\"hljs bash\">svn import myrepo file:///home/svn/repo -m <span class=\"hljs-string\">&quot;Initial import&quot;</span></code></pre>\n<p><strong><code>export</code></strong>: 将项目从服务器导出到本地，跟checkout对应，但是导出的文件夹不含.svn目录，脱离svn版本控制。</p>\n<pre><code class=\"hljs bash\">svn <span class=\"hljs-built_in\">export</span> -r version file:///home/svn/repo</code></pre>\n<p>（通过 <em><code>-r version</code></em> 导出指定版本，不加则默认导出最新版本。）</p>\n<p><strong><code>checkout</code></strong>: 从服务器仓库下载项目到本地，成为本地工作副本。<br><pre><code class=\"hljs bash\">svn checkout file:///home/svn/repo -r version\n或者\nsvn co -r version file:///home/svn/repo</code></pre><br>（通过 <em><code>-r version</code></em> 导出指定版本，不加则默认下载最新版本。）</p>\n<p><strong><code>trunk, branches, tags</code></strong> 三大目录：</p>\n<p>　trunk: 主干，一般把项目提交到此文件夹里面,在trunk中开发。<br>　branches: 分支，一般把那些需要打分支,但是有可能会修改的项目代码，打分支到此目录。<br>　tags: 分支，一般把那些阶段性(如迭代各期)的项目代码,打分支到此目录。</p>\n<p>新建的svn仓库中没有这三个文件夹，可通过下面两种方式创建：</p>\n<ol>\n<li>将项目从服务器下载到本地，进入生成的项目目录执行以下代码：</li>\n</ol>\n<pre><code class=\"hljs bash\">svn mkdir trunk tags branches\nsvn commit -m　<span class=\"hljs-string\">&quot;Creating trunk, tags, branches&quot;</span></code></pre>\n<ol start=\"2\">\n<li>如果不想将项目整个下载到本地，也可以直接使用一条命令创建并提交目录到svn服务器：</li>\n</ol>\n<pre><code class=\"hljs bash\">svn mkdir file:///home/svn/repo/trunk -m <span class=\"hljs-string\">&quot;Creating trunk dir&quot;</span></code></pre>\n<p>另外两个目录使用同样的方式进行创建并提交。</p>\n<p><strong><code>status</code></strong>: 查看工作副本状态。</p>\n<pre><code class=\"hljs bash\">svn status</code></pre>\n<p>第一列表示文件的状态：<br>　，没有修订<br>　A，添加<br>　C，冲突，需要解决冲突状态，才能正常提交代码<br>　D，删除<br>　I，忽略<br>　M，有修改<br>　?，没有版本控制，在工作副本添加文件或目录之后，需要使用svn add your_path才能加该文件加到版本控制<br>　!，文件丢失，如果不是使用svn delete删除文件或目录，会产生此状态</p>\n<p><strong><code>info</code></strong>: 查看工作副本信息。</p>\n<pre><code class=\"hljs bash\">svn info</code></pre>\n<p>能够查看到本工作副本的url、版本等信息。</p>\n<p><strong><code>update</code></strong>: 升级到新版本。</p>\n<pre><code class=\"hljs bash\">svn update -r verison</code></pre>\n<p><strong><code>add</code></strong>: 添加新文件或者目录到版本控制。</p>\n<pre><code class=\"hljs bash\">svn add file\nsvn add dir</code></pre>\n<p><strong><code>delete</code></strong>: 删除文件或目录。</p>\n<pre><code class=\"hljs bash\">svn delete file\nsvn delete dir</code></pre>\n<p>如果仅仅是手动使用rm命令或窗口下删除工作副本内的文件或目录，该删除并不会记录svn的状态。可能会导致提交代码时，遗漏了删除文件或目录。因此建议删除svn工作副本内的文件或目录时，使用本命令进行操作。</p>\n<p><strong><code>commit</code></strong>: 提交代码。</p>\n<pre><code class=\"hljs bash\">svn commit [-m message] [file_list]</code></pre>\n<p>如果没有带文件列表，默认把工作副本的所有修订都提交，如果有带文件列表，则只提交文件列表中对应文件的修订。</p>\n<p><strong><code>merge</code></strong>: 合并代码。</p>\n<pre><code class=\"hljs bash\">svn merge -r ver1:ver2 src_url working_copy_path</code></pre>\n<p>可将任意版本的任意修订合并到工作副本中。如果ver1小于ver2，表示合并src_url分支ver1到ver2的修订到本地工作副本；如果ver1大于ver2，表示回退修订。</p>\n<p><strong><code>revert</code></strong>: 回退工作副本的修订。<br><pre><code class=\"hljs bash\">svn revert file\nsvn revert -R dir</code></pre></p>\n<p><strong><code>log</code></strong>: 查看版本log。</p>\n<pre><code class=\"hljs bash\">svn <span class=\"hljs-built_in\">log</span> [OPTIONS] [FILE_LIST]</code></pre>\n<p>默认只查看工作副本及以前版本的log，可以使用参数过滤得到我们想要的内容，详情请见 <em><code>svn log --help</code></em> 。</p>\n<hr>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://help.ubuntu.com/community/Subversion\">Subversion</a></li>\n<li><a href=\"https://www.jianshu.com/p/0a8cf8bcdacc\">SVN基础用法</a></li>\n<li><a href=\"https://www.jianshu.com/p/6b83b6f2cace\">Ubuntu搭建svn服务器</a></li>\n<li><a href=\"http://ourjs.com/detail/5b1ca77b7ad90c6e47f34b72\">Linux搭建SVN服务器，并设置开机默认启动</a></li>\n</ol>"},{"title":"机器学习（Machine Learning）学习总结","date":"2020-08-13T11:26:02.000Z","_content":"\n人工智能（Artificial Intelligence）、机器学习（Machine Learning）、深度学习（Deep Learning）、神经网络（Neutral Network）等等这些专业术语在平时学习和工作中经常出现，但有时感觉似懂非懂，傻傻分不清楚，所以决定在此简单的总结一下。\n\n<!--more-->\n\n![AI](Machine-Learning/AI.png)\n\n从上图可以看出，**人工智能、机器学习、神经网络、深度学习之间是包含关系**，「人工智能」是最大的圈，它包括「机器学习」（机器根据数据“自学”）和「非机器学习」（机器从人直接获取指令）。「神经网络」是「机器学习」的一部分，它是由一个个「神经元」搭建的系统，多层的「神经网络」就叫做「深度学习」。\n\n## 人工智能\n\n**人工智能（Artificial Intelligence）是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门技术科学。** 简单地说，就是给机器赋予人的智能。其基本原理：机器从「特定的」大量数据中总结规律，形成某些「特定的知识」，然后将这种「知识」应用到现实场景中去解决实际问题。\n\n人工智能可分三个级别：\n1. **弱人工智能**：限定领域解决特定问题。\n2. **强人工智能**：通用领域胜任人类所有工作。\n3. **超人工智能**：远超人类智慧。\n\n我们现在还处在弱人工智能阶段，强人工智能还远没有实现，而超人工智能更是连影子都看不到。\n\n## 机器学习\n\n**机器学习（Machine Learning）是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。** 机器学习是人工智能的核心，是使计算机具有智能的根本途径，最基本的做法是使用算法解析数据、从中学习，然后对真实世界中的事件作出决策或预测。\n\n## 机器学习分类\n\n按模型训练方式分：\n* 监督学习（Supervised Learning）\n* 无监督学习（Unsupervised Learning）\n* 半监督学习（Semi-supervised Learning）\n* 强化学习（Reinforcement Learning）\n\n### 监督学习\n\n监督学习（Supervised Learning）是从有标记的训练数据中推导出预测函数，需要有明确的目标，清楚自己想要什么结果。简言之：**给定数据，预测标签。**\n\n监督并不是人站在机器旁边看机器做的对不对，而是下面的流程：\n1. 选择合适的模型\n2. 把已知的“问题和答案”（训练集）提供给机器去学习\n3. 机器总结出自己的“方法论”\n4. 把“新的问题”（测试集）提供给机器去解答\n\n监督学习的特点：\n* 目标明确\n* 需要带标签的训练数据\n* 效果容易评估\n\n监督学习主要任务：\n* **回归**：预测连续的、具体的数值\n* **分类**：对各种事物分类，用于离散型预测\n\n### 无监督学习\n\n无监督学习（Unsupervised Learning）本质上是一种统计手段，在没有标签的数据里发现潜在的一些结构的训练方法。简言之：**给定数据，寻找隐藏的结构。**\n\n无监督学习的特点：\n* 没有明确的目的\n* 不需要给数据打标签\n* 无法量化效果\n\n无监督学习应用场景：\n* 发现异常数据\n* 细分用户\n* 给用户做推荐\n\n无监督学习主要任务:\n* **聚类**：简单说就是一种自动分类的方法，在监督学习中，你很清楚每一个分类是什么，但是聚类则不是，你并去清楚聚类后的每个分类代表什么意思。\n* **降维**：感觉像是压缩，是为了在尽可能保存相关的结构的同时降低数据的复杂度。\n\n### 半监督学习\n\n半监督学习（Semi-supervised Learning）属于无监督学习和监督学习之间，使用标记和未标记的数据来执行有监督学习或者无监督学习任务。\n\n### 强化学习\n\n强化学习（Reinforcement Learning）主要基于决策进行训练，根据输出结果（决策）的成功或失败来训练算法，通过大量经验训练优化后的算法将能够给出较好的预测。简言之：**给定数据，学习如何选择一系列行动，以最大化长期收益。**\n\n强化学习特点：\n* 决策流程\n* 激励系统\n* 学习一系列的行动\n\n强化学习主要任务：\n* **科学决策**：优化决策以得到最佳结果。\n* **动态规划**：把复杂问题分解成若干个子问题，通过寻找子问提的最优解来得到复杂问题的最优解。\n\n\n## 机器学习任务\n\n最常见的机器学习任务有三种：\n* 回归（Regression）\n* 分类（Classification）\n* 聚类（Clustering）\n\n### 回归\n\n回归算法是一种对数值型连续随机变量进行预测和建模的监督学习方法。使用案例包括房价预测、股票走势或测试成绩等连续变化的案例。\n\n回归任务的特点是标注的数据集具有数值型的目标变量。也就是说，每一个观察样本都有一个数值型的标注真值以监督算法。\n\n#### 线性回归\n\n线性回归（Linear Regression）是处理回归任务最常用的算法之一。该算法的形式十分简单，它期望使用一个超平面拟合数据集（只有两个变量的时候就是一条直线）。如果数据集中的变量存在线性关系，那么其就能拟合地非常好。\n\n![linear-gression](Machine-Learning/linear-regression.png)\n\n线性回归算法的建模过程就是使用数据点来寻找最佳拟合线。线性回归分为两种类型，即 **简单线性回归（Simple Linear Regression）**，只有一个自变量；和 **多变量回归（Multiple Regression）**，至少两组以上自变量。\n\n* 优点：线性回归的理解与解释都十分直观，并且还能通过正则化来降低过拟合的风险。另外，线性模型很容易使用随机梯度下降和新数据更新模型权重。\n* 线性回归在变量是非线性关系的时候表现很差。并且其也不够灵活以捕捉更复杂的模式，添加正确的交互项或使用多项式很困难并需要大量时间。\n\n#### 回归树\n\n回归树（Regression Tree）（回归决策树，决策树的一种）通过将数据集重复分割为不同的分支而实现分层学习，分割的标准是最大化每一次分离的信息增益。这种分支结构让回归树很自然地学习到非线性关系。\n\n![regression-tree](Machine-Learning/regression-tree.png)\n\n单一的回归树往往是不够用的，可以利用集成学习中的boosting框架对回归树进行改良升级，如 **梯度提升树（Gradient Boost Decision Tree）** 就是集成了许多独立训练的树。这种算法的主要思想就是组合多个弱学习算法而成为一种强学习算法。\n\n* 优点：决策树能学习非线性关系，对异常值也具有很强的鲁棒性。集成学习在实践中表现非常好，其经常赢得许多经典的（非深度学习）机器学习竞赛。\n\n* 缺点：无约束的，单棵树很容易过拟合，因为单棵树可以保留分支（不剪枝），并直到其记住了训练数据。集成方法可以削弱这一缺点的影响。\n\n#### 深度学习\n\n深度学习（Deep Learning）是指能学习极其复杂模式的多层神经网络。该算法使用在输入层和输出层之间的隐藏层对数据的中间表征建模，这也是其他算法很难学到的部分。\n\n![deep-learning](Machine-Learning/deep-learning-regression.png)\n\n深度学习还有其他几个重要的机制，如卷积和 drop-out 等，这些机制令该算法能有效地学习到高维数据。然而深度学习相对于其他算法需要更多的数据，因为其有更大数量级的参数需要估计。\n\n* 优点：深度学习是目前某些领域最先进的技术，如计算机视觉和语音识别等。深度神经网络在图像、音频和文本等数据上表现优异，并且该算法也很容易对新数据使用反向传播算法更新模型参数。它们的架构（即层级的数量和结构）能够适应于多种问题，并且隐藏层也减少了算法对特征工程的依赖。\n\n* 缺点：深度学习算法通常不适合作为通用目的的算法，因为其需要大量的数据。实际上，深度学习通常在经典机器学习问题上并没有集成方法表现得好。另外，其在训练上是计算密集型的，所以这就需要更富经验的人进行调参（即设置架构和超参数）以减少训练时间。\n\n### 分类\n\n分类方法是一种对离散型随机变量建模或预测的监督学习算法。使用案例包括邮件过滤、金融欺诈和预测雇员异动等输出为类别的任务。\n\n许多回归算法都有与其相对应的分类算法，分类算法通常适用于预测一个类别（或类别的概率）而不是连续的数值。\n\n#### 分类树\n\n分类树（Classification Tree）（分类决策树，和回归树对应也是决策树的一种）。\n相应的，**随机森林（Random Forest）** 是分类树的一种集成形式。\n\n![random-forest](Machine-Learning/random-forest.png)\n\n* 优点：同回归方法一样，分类树的集成方法在实践中同样表现十分优良。它们通常对异常数据具有相当的鲁棒性和可扩展性。因为它的层级结构，分类树的集成方法能很自然地对非线性决策边界建模。\n\n* 缺点：不可约束，单棵树趋向于过拟合，使用集成方法可以削弱这一方面的影响。\n\n#### 逻辑回归\n\n逻辑回归（Logistic Regression）是与线性回归相对应的一种分类方法，一般用于需要明确输出的场景，如某些事件的发生（预测是否会发生降雨）。通常，逻辑回归使用某种函数将概率值压缩到某一特定范围。逻辑回归通过逻辑函数（即Sigmoid函数）将预测映射到0到1中间，因此预测值就可以看成某个类别的概率。\n\n![logistic-regression](Machine-Learning/logistic-regression.png)\n\n该模型仍然还是「线性」的，所以只有在数据是线性可分（即数据可被一个超平面完全分离）时，算法才能有优秀的表现。同样 Logistic 模型能惩罚模型系数而进行正则化。\n\n* 优点：输出有很好的概率解释，并且算法也能正则化而避免过拟合。Logistic 模型很容易使用随机梯度下降和新数据更新模型权重。\n\n* 缺点：Logistic 回归在多条或非线性决策边界时性能比较差。\n\n#### k-最近邻算法\n\nk-最近邻算法（k-Nearest Neighbor, KNN）是一种基本分类和回归方法，即给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的k个实例，这k个实例的多数属于某个类，就把该输入实例分到这个类中。用最近的邻居（k）来预测未知数据点。k值是预测精度的一个关键因素，无论是分类还是回归，衡量邻居的权重都非常有用，较近邻居的权重比较远邻居的权重大。\n\n![KNN](Machine-Learning/KNN.png)\n\n用KNN算法给新输入的实例分类，只要找到离它最近的k个实例，看哪个类别多即可。而k值的选取，既不能太小，也不能太大，需要实验调整参数确定。\n\n* 优点：简单好用，容易理解，精度高，可用于数值型和离散型数据。\n* 缺点：对数据的局部结构非常敏感，计算量大，需要对数据进行规范化处理，使每个数据点都在相同的范围。\n\n#### 支持向量机\n\n支持向量机（Support Vector Machine, SVM）可以使用一个称之为核函数的技巧扩展到非线性分类问题，而该算法本质上就是计算两个称之为支持向量的观测数据之间的距离。SVM 算法寻找的决策边界即最大化其与样本间隔的边界，因此支持向量机又称为大间距分类器。需要注意的是，支持向量机需要对输入数据进行完全标记，仅直接适用于两类任务，应用到多类任务时需要将其减少到几个二元问题。\n\n![svm](Machine-Learning/svm.png)\n\nSVM使用线性核函数就能得到类似于logistic回归的结果，只不过支持向量机因为最大化了间隔而更具鲁棒性。因此，在实践中，SVM最大的优点就是可以使用非线性核函数对非线性决策边界建模。\n\n* 优点：SVM 能对非线性决策边界建模，并且有许多可选的核函数形式。SVM同样面对过拟合有相当大的鲁棒性，这一点在高维空间中尤其突出。\n* 缺点：然而，SVM是内存密集型算法，由于选择正确的核函数是很重要的，所以其很难调参，也不能扩展到较大的数据集中。目前在工业界中，随机森林通常优于支持向量机算法。\n\n#### 朴素贝叶斯\n\n朴素贝叶斯（Naive Bayes）是一种基于贝叶斯定理和特征条件独立假设的分类方法。本质上朴素贝叶斯模型就是一个概率表，其通过训练数据更新这张表中的概率。为了预测一个新的观察值，朴素贝叶斯算法就是根据样本的特征值在概率表中寻找最大概率的那个类别。之所以称之为「朴素」，是因为该算法的核心就是特征条件独立性假设（每一个特征之间相互独立），而这一假设在现实世界中基本是不现实的。\n\n$P(y|x_1,...,x_n)=\\frac{P(y)\\prod(^n_{i=1}P(x_i|y)))}{P(x_1,...,x_n)}$\n\n* 优点：即使条件独立性假设很难成立，但朴素贝叶斯算法在实践中表现出乎意料地好。该算法很容易实现并能随数据集的更新而扩展。\n* 缺点：因为朴素贝叶斯算法太简单了，所以其也经常被以上列出的分类算法所替代。\n\n#### 深度学习\n\n深度学习（Deep Learning）同样很容易适应于分类问题。实际上，深度学习应用更多的是分类任务，如图像分类等。\n\n* 优点：深度学习非常适用于分类音频、文本和图像数据。\n*缺点：和回归问题一样，深度神经网络需要大量的数据进行训练，所以其也不是一个通用目的的算法。\n\n### 聚类\n\n聚类是一种无监督学习任务，该算法基于数据的内部结构寻找观察样本的自然族群（即集群）。使用案例包括细分客户、新闻聚类、文章推荐等。\n\n因为聚类是一种无监督学习（即数据没有标注），并且通常使用数据可视化评价结果。如果存在「正确的回答」（即在训练集中存在预标注的集群），那么分类算法可能更加合适。\n\n#### k均值聚类\n\nk均值聚类（K-Means Clustering）是一种通用目的的算法，聚类的度量基于样本点之间的几何距离（即在坐标平面中的距离）。集群是围绕在聚类中心的族群，而集群呈现出类球状并具有相似的大小。\n\n![k-mans](Machine-Learning/k-means.png)\n\nK-Means算法把n个点（可以是样本的一次观察或一个实例）划分到k个集群（cluster），使得每个点都属于离他最近的均值（即聚类中心，centroid）对应的集群。重复上述过程一直持续到重心不改变。\n\n* 优点：K 均值聚类是最流行的聚类算法，因为该算法足够快速、简单，并且如果你的预处理数据和特征工程十分有效，那么该聚类算法将拥有令人惊叹的灵活性。\n* 缺点：该算法需要指定集群的数量，而 K 值的选择通常都不是那么容易确定的。另外，如果训练数据中的真实集群并不是类球状的，那么 K 均值聚类会得出一些比较差的集群。\n\n#### 层次聚类\n\n层次聚类（Hierarchical Clustering）通过计算不同类别数据点之间的相似度来创建一棵有层次的嵌套聚类树，在聚类树中，不同类别的原始数据点是树的最底层，树的顶层是一个聚类的根节点。创建聚类树有自下而上合并和自上而下分裂两种方法，常见的是合并方法。\n\n![HC](Machine-Learning/HC.png)\n\n层次聚类的合并算法是通过计算每一个类别的数据点与所有数据点之间的距离来确定它们之间的相似性，距离越小，相似度越高。并将距离最近的两个数据点或类别进行组合，生成聚类树。\n\n* 优点：层次聚类最主要的优点是集群不再需要假设为类球形。另外其也可以扩展到大数据集。\n* 缺点：有点像k均值聚类，该算法需要设定集群的数量（即在算法完成后需要保留的层次）。\n\n## 神经网络\n\n神经网络（Neural Networks)是人工智能领域机器学习一部分，就好像人体的神经元、神经系统一样，人工智能的神经网络就是由一个个神经元搭建的系统，多层的神经网络就叫做深度神经网络（Deep Neural Network, **DNN**），也就是深度学习。它是机器学习最重要的一个分支，也是最流行一种的机器学习算法！\n\nDNN已经演变成许多不同的网络拓扑结构，比如，卷积神经网络（Convolutional Neural Networks, **CNN**）、循环神经网络（Recurrent Neural Networks, **RNN**）、长短期记忆（Long Short Term Memory, **LSTM**）、生成敌对网络（Generativ Adversarial Networks, **GAN**）等。\n\n\n---\n\n## 参考\n\n1. [人工智能相关知识](https://easyai.tech/ai-definition/ai/)\n2. [回归、分类与聚类](https://www.jiqizhixin.com/articles/2017-05-20-3)\n3. [Machine Learning:十大机器学习算法](https://zhuanlan.zhihu.com/p/33794257)\n4. [Understanding Neutral Networks](https://towardsdatascience.com/understanding-neural-networks-from-neuron-to-rnn-cnn-and-deep-learning-cd88e90e0a90)","source":"_posts/Machine-Learning.md","raw":"---\ntitle: 机器学习（Machine Learning）学习总结\ndate: 2020-08-13 13:26:02\ntags:\n- machine Learning\n- introduction\ncategories:\n- [机器学习（machine learning）]\n---\n\n人工智能（Artificial Intelligence）、机器学习（Machine Learning）、深度学习（Deep Learning）、神经网络（Neutral Network）等等这些专业术语在平时学习和工作中经常出现，但有时感觉似懂非懂，傻傻分不清楚，所以决定在此简单的总结一下。\n\n<!--more-->\n\n![AI](Machine-Learning/AI.png)\n\n从上图可以看出，**人工智能、机器学习、神经网络、深度学习之间是包含关系**，「人工智能」是最大的圈，它包括「机器学习」（机器根据数据“自学”）和「非机器学习」（机器从人直接获取指令）。「神经网络」是「机器学习」的一部分，它是由一个个「神经元」搭建的系统，多层的「神经网络」就叫做「深度学习」。\n\n## 人工智能\n\n**人工智能（Artificial Intelligence）是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门技术科学。** 简单地说，就是给机器赋予人的智能。其基本原理：机器从「特定的」大量数据中总结规律，形成某些「特定的知识」，然后将这种「知识」应用到现实场景中去解决实际问题。\n\n人工智能可分三个级别：\n1. **弱人工智能**：限定领域解决特定问题。\n2. **强人工智能**：通用领域胜任人类所有工作。\n3. **超人工智能**：远超人类智慧。\n\n我们现在还处在弱人工智能阶段，强人工智能还远没有实现，而超人工智能更是连影子都看不到。\n\n## 机器学习\n\n**机器学习（Machine Learning）是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。** 机器学习是人工智能的核心，是使计算机具有智能的根本途径，最基本的做法是使用算法解析数据、从中学习，然后对真实世界中的事件作出决策或预测。\n\n## 机器学习分类\n\n按模型训练方式分：\n* 监督学习（Supervised Learning）\n* 无监督学习（Unsupervised Learning）\n* 半监督学习（Semi-supervised Learning）\n* 强化学习（Reinforcement Learning）\n\n### 监督学习\n\n监督学习（Supervised Learning）是从有标记的训练数据中推导出预测函数，需要有明确的目标，清楚自己想要什么结果。简言之：**给定数据，预测标签。**\n\n监督并不是人站在机器旁边看机器做的对不对，而是下面的流程：\n1. 选择合适的模型\n2. 把已知的“问题和答案”（训练集）提供给机器去学习\n3. 机器总结出自己的“方法论”\n4. 把“新的问题”（测试集）提供给机器去解答\n\n监督学习的特点：\n* 目标明确\n* 需要带标签的训练数据\n* 效果容易评估\n\n监督学习主要任务：\n* **回归**：预测连续的、具体的数值\n* **分类**：对各种事物分类，用于离散型预测\n\n### 无监督学习\n\n无监督学习（Unsupervised Learning）本质上是一种统计手段，在没有标签的数据里发现潜在的一些结构的训练方法。简言之：**给定数据，寻找隐藏的结构。**\n\n无监督学习的特点：\n* 没有明确的目的\n* 不需要给数据打标签\n* 无法量化效果\n\n无监督学习应用场景：\n* 发现异常数据\n* 细分用户\n* 给用户做推荐\n\n无监督学习主要任务:\n* **聚类**：简单说就是一种自动分类的方法，在监督学习中，你很清楚每一个分类是什么，但是聚类则不是，你并去清楚聚类后的每个分类代表什么意思。\n* **降维**：感觉像是压缩，是为了在尽可能保存相关的结构的同时降低数据的复杂度。\n\n### 半监督学习\n\n半监督学习（Semi-supervised Learning）属于无监督学习和监督学习之间，使用标记和未标记的数据来执行有监督学习或者无监督学习任务。\n\n### 强化学习\n\n强化学习（Reinforcement Learning）主要基于决策进行训练，根据输出结果（决策）的成功或失败来训练算法，通过大量经验训练优化后的算法将能够给出较好的预测。简言之：**给定数据，学习如何选择一系列行动，以最大化长期收益。**\n\n强化学习特点：\n* 决策流程\n* 激励系统\n* 学习一系列的行动\n\n强化学习主要任务：\n* **科学决策**：优化决策以得到最佳结果。\n* **动态规划**：把复杂问题分解成若干个子问题，通过寻找子问提的最优解来得到复杂问题的最优解。\n\n\n## 机器学习任务\n\n最常见的机器学习任务有三种：\n* 回归（Regression）\n* 分类（Classification）\n* 聚类（Clustering）\n\n### 回归\n\n回归算法是一种对数值型连续随机变量进行预测和建模的监督学习方法。使用案例包括房价预测、股票走势或测试成绩等连续变化的案例。\n\n回归任务的特点是标注的数据集具有数值型的目标变量。也就是说，每一个观察样本都有一个数值型的标注真值以监督算法。\n\n#### 线性回归\n\n线性回归（Linear Regression）是处理回归任务最常用的算法之一。该算法的形式十分简单，它期望使用一个超平面拟合数据集（只有两个变量的时候就是一条直线）。如果数据集中的变量存在线性关系，那么其就能拟合地非常好。\n\n![linear-gression](Machine-Learning/linear-regression.png)\n\n线性回归算法的建模过程就是使用数据点来寻找最佳拟合线。线性回归分为两种类型，即 **简单线性回归（Simple Linear Regression）**，只有一个自变量；和 **多变量回归（Multiple Regression）**，至少两组以上自变量。\n\n* 优点：线性回归的理解与解释都十分直观，并且还能通过正则化来降低过拟合的风险。另外，线性模型很容易使用随机梯度下降和新数据更新模型权重。\n* 线性回归在变量是非线性关系的时候表现很差。并且其也不够灵活以捕捉更复杂的模式，添加正确的交互项或使用多项式很困难并需要大量时间。\n\n#### 回归树\n\n回归树（Regression Tree）（回归决策树，决策树的一种）通过将数据集重复分割为不同的分支而实现分层学习，分割的标准是最大化每一次分离的信息增益。这种分支结构让回归树很自然地学习到非线性关系。\n\n![regression-tree](Machine-Learning/regression-tree.png)\n\n单一的回归树往往是不够用的，可以利用集成学习中的boosting框架对回归树进行改良升级，如 **梯度提升树（Gradient Boost Decision Tree）** 就是集成了许多独立训练的树。这种算法的主要思想就是组合多个弱学习算法而成为一种强学习算法。\n\n* 优点：决策树能学习非线性关系，对异常值也具有很强的鲁棒性。集成学习在实践中表现非常好，其经常赢得许多经典的（非深度学习）机器学习竞赛。\n\n* 缺点：无约束的，单棵树很容易过拟合，因为单棵树可以保留分支（不剪枝），并直到其记住了训练数据。集成方法可以削弱这一缺点的影响。\n\n#### 深度学习\n\n深度学习（Deep Learning）是指能学习极其复杂模式的多层神经网络。该算法使用在输入层和输出层之间的隐藏层对数据的中间表征建模，这也是其他算法很难学到的部分。\n\n![deep-learning](Machine-Learning/deep-learning-regression.png)\n\n深度学习还有其他几个重要的机制，如卷积和 drop-out 等，这些机制令该算法能有效地学习到高维数据。然而深度学习相对于其他算法需要更多的数据，因为其有更大数量级的参数需要估计。\n\n* 优点：深度学习是目前某些领域最先进的技术，如计算机视觉和语音识别等。深度神经网络在图像、音频和文本等数据上表现优异，并且该算法也很容易对新数据使用反向传播算法更新模型参数。它们的架构（即层级的数量和结构）能够适应于多种问题，并且隐藏层也减少了算法对特征工程的依赖。\n\n* 缺点：深度学习算法通常不适合作为通用目的的算法，因为其需要大量的数据。实际上，深度学习通常在经典机器学习问题上并没有集成方法表现得好。另外，其在训练上是计算密集型的，所以这就需要更富经验的人进行调参（即设置架构和超参数）以减少训练时间。\n\n### 分类\n\n分类方法是一种对离散型随机变量建模或预测的监督学习算法。使用案例包括邮件过滤、金融欺诈和预测雇员异动等输出为类别的任务。\n\n许多回归算法都有与其相对应的分类算法，分类算法通常适用于预测一个类别（或类别的概率）而不是连续的数值。\n\n#### 分类树\n\n分类树（Classification Tree）（分类决策树，和回归树对应也是决策树的一种）。\n相应的，**随机森林（Random Forest）** 是分类树的一种集成形式。\n\n![random-forest](Machine-Learning/random-forest.png)\n\n* 优点：同回归方法一样，分类树的集成方法在实践中同样表现十分优良。它们通常对异常数据具有相当的鲁棒性和可扩展性。因为它的层级结构，分类树的集成方法能很自然地对非线性决策边界建模。\n\n* 缺点：不可约束，单棵树趋向于过拟合，使用集成方法可以削弱这一方面的影响。\n\n#### 逻辑回归\n\n逻辑回归（Logistic Regression）是与线性回归相对应的一种分类方法，一般用于需要明确输出的场景，如某些事件的发生（预测是否会发生降雨）。通常，逻辑回归使用某种函数将概率值压缩到某一特定范围。逻辑回归通过逻辑函数（即Sigmoid函数）将预测映射到0到1中间，因此预测值就可以看成某个类别的概率。\n\n![logistic-regression](Machine-Learning/logistic-regression.png)\n\n该模型仍然还是「线性」的，所以只有在数据是线性可分（即数据可被一个超平面完全分离）时，算法才能有优秀的表现。同样 Logistic 模型能惩罚模型系数而进行正则化。\n\n* 优点：输出有很好的概率解释，并且算法也能正则化而避免过拟合。Logistic 模型很容易使用随机梯度下降和新数据更新模型权重。\n\n* 缺点：Logistic 回归在多条或非线性决策边界时性能比较差。\n\n#### k-最近邻算法\n\nk-最近邻算法（k-Nearest Neighbor, KNN）是一种基本分类和回归方法，即给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的k个实例，这k个实例的多数属于某个类，就把该输入实例分到这个类中。用最近的邻居（k）来预测未知数据点。k值是预测精度的一个关键因素，无论是分类还是回归，衡量邻居的权重都非常有用，较近邻居的权重比较远邻居的权重大。\n\n![KNN](Machine-Learning/KNN.png)\n\n用KNN算法给新输入的实例分类，只要找到离它最近的k个实例，看哪个类别多即可。而k值的选取，既不能太小，也不能太大，需要实验调整参数确定。\n\n* 优点：简单好用，容易理解，精度高，可用于数值型和离散型数据。\n* 缺点：对数据的局部结构非常敏感，计算量大，需要对数据进行规范化处理，使每个数据点都在相同的范围。\n\n#### 支持向量机\n\n支持向量机（Support Vector Machine, SVM）可以使用一个称之为核函数的技巧扩展到非线性分类问题，而该算法本质上就是计算两个称之为支持向量的观测数据之间的距离。SVM 算法寻找的决策边界即最大化其与样本间隔的边界，因此支持向量机又称为大间距分类器。需要注意的是，支持向量机需要对输入数据进行完全标记，仅直接适用于两类任务，应用到多类任务时需要将其减少到几个二元问题。\n\n![svm](Machine-Learning/svm.png)\n\nSVM使用线性核函数就能得到类似于logistic回归的结果，只不过支持向量机因为最大化了间隔而更具鲁棒性。因此，在实践中，SVM最大的优点就是可以使用非线性核函数对非线性决策边界建模。\n\n* 优点：SVM 能对非线性决策边界建模，并且有许多可选的核函数形式。SVM同样面对过拟合有相当大的鲁棒性，这一点在高维空间中尤其突出。\n* 缺点：然而，SVM是内存密集型算法，由于选择正确的核函数是很重要的，所以其很难调参，也不能扩展到较大的数据集中。目前在工业界中，随机森林通常优于支持向量机算法。\n\n#### 朴素贝叶斯\n\n朴素贝叶斯（Naive Bayes）是一种基于贝叶斯定理和特征条件独立假设的分类方法。本质上朴素贝叶斯模型就是一个概率表，其通过训练数据更新这张表中的概率。为了预测一个新的观察值，朴素贝叶斯算法就是根据样本的特征值在概率表中寻找最大概率的那个类别。之所以称之为「朴素」，是因为该算法的核心就是特征条件独立性假设（每一个特征之间相互独立），而这一假设在现实世界中基本是不现实的。\n\n$P(y|x_1,...,x_n)=\\frac{P(y)\\prod(^n_{i=1}P(x_i|y)))}{P(x_1,...,x_n)}$\n\n* 优点：即使条件独立性假设很难成立，但朴素贝叶斯算法在实践中表现出乎意料地好。该算法很容易实现并能随数据集的更新而扩展。\n* 缺点：因为朴素贝叶斯算法太简单了，所以其也经常被以上列出的分类算法所替代。\n\n#### 深度学习\n\n深度学习（Deep Learning）同样很容易适应于分类问题。实际上，深度学习应用更多的是分类任务，如图像分类等。\n\n* 优点：深度学习非常适用于分类音频、文本和图像数据。\n*缺点：和回归问题一样，深度神经网络需要大量的数据进行训练，所以其也不是一个通用目的的算法。\n\n### 聚类\n\n聚类是一种无监督学习任务，该算法基于数据的内部结构寻找观察样本的自然族群（即集群）。使用案例包括细分客户、新闻聚类、文章推荐等。\n\n因为聚类是一种无监督学习（即数据没有标注），并且通常使用数据可视化评价结果。如果存在「正确的回答」（即在训练集中存在预标注的集群），那么分类算法可能更加合适。\n\n#### k均值聚类\n\nk均值聚类（K-Means Clustering）是一种通用目的的算法，聚类的度量基于样本点之间的几何距离（即在坐标平面中的距离）。集群是围绕在聚类中心的族群，而集群呈现出类球状并具有相似的大小。\n\n![k-mans](Machine-Learning/k-means.png)\n\nK-Means算法把n个点（可以是样本的一次观察或一个实例）划分到k个集群（cluster），使得每个点都属于离他最近的均值（即聚类中心，centroid）对应的集群。重复上述过程一直持续到重心不改变。\n\n* 优点：K 均值聚类是最流行的聚类算法，因为该算法足够快速、简单，并且如果你的预处理数据和特征工程十分有效，那么该聚类算法将拥有令人惊叹的灵活性。\n* 缺点：该算法需要指定集群的数量，而 K 值的选择通常都不是那么容易确定的。另外，如果训练数据中的真实集群并不是类球状的，那么 K 均值聚类会得出一些比较差的集群。\n\n#### 层次聚类\n\n层次聚类（Hierarchical Clustering）通过计算不同类别数据点之间的相似度来创建一棵有层次的嵌套聚类树，在聚类树中，不同类别的原始数据点是树的最底层，树的顶层是一个聚类的根节点。创建聚类树有自下而上合并和自上而下分裂两种方法，常见的是合并方法。\n\n![HC](Machine-Learning/HC.png)\n\n层次聚类的合并算法是通过计算每一个类别的数据点与所有数据点之间的距离来确定它们之间的相似性，距离越小，相似度越高。并将距离最近的两个数据点或类别进行组合，生成聚类树。\n\n* 优点：层次聚类最主要的优点是集群不再需要假设为类球形。另外其也可以扩展到大数据集。\n* 缺点：有点像k均值聚类，该算法需要设定集群的数量（即在算法完成后需要保留的层次）。\n\n## 神经网络\n\n神经网络（Neural Networks)是人工智能领域机器学习一部分，就好像人体的神经元、神经系统一样，人工智能的神经网络就是由一个个神经元搭建的系统，多层的神经网络就叫做深度神经网络（Deep Neural Network, **DNN**），也就是深度学习。它是机器学习最重要的一个分支，也是最流行一种的机器学习算法！\n\nDNN已经演变成许多不同的网络拓扑结构，比如，卷积神经网络（Convolutional Neural Networks, **CNN**）、循环神经网络（Recurrent Neural Networks, **RNN**）、长短期记忆（Long Short Term Memory, **LSTM**）、生成敌对网络（Generativ Adversarial Networks, **GAN**）等。\n\n\n---\n\n## 参考\n\n1. [人工智能相关知识](https://easyai.tech/ai-definition/ai/)\n2. [回归、分类与聚类](https://www.jiqizhixin.com/articles/2017-05-20-3)\n3. [Machine Learning:十大机器学习算法](https://zhuanlan.zhihu.com/p/33794257)\n4. [Understanding Neutral Networks](https://towardsdatascience.com/understanding-neural-networks-from-neuron-to-rnn-cnn-and-deep-learning-cd88e90e0a90)","slug":"Machine-Learning","published":1,"updated":"2020-08-16T21:48:10.572Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdypyf72000em4k20t25cdnx","content":"<p>人工智能（Artificial Intelligence）、机器学习（Machine Learning）、深度学习（Deep Learning）、神经网络（Neutral Network）等等这些专业术语在平时学习和工作中经常出现，但有时感觉似懂非懂，傻傻分不清楚，所以决定在此简单的总结一下。</p>\n<a id=\"more\"></a>\n<p><img src=\"/2020/08/13/Machine-Learning/AI.png\" alt=\"AI\"></p>\n<p>从上图可以看出，<strong>人工智能、机器学习、神经网络、深度学习之间是包含关系</strong>，「人工智能」是最大的圈，它包括「机器学习」（机器根据数据“自学”）和「非机器学习」（机器从人直接获取指令）。「神经网络」是「机器学习」的一部分，它是由一个个「神经元」搭建的系统，多层的「神经网络」就叫做「深度学习」。</p>\n<h2 id=\"人工智能\"><a href=\"#人工智能\" class=\"headerlink\" title=\"人工智能\"></a>人工智能</h2><p><strong>人工智能（Artificial Intelligence）是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门技术科学。</strong> 简单地说，就是给机器赋予人的智能。其基本原理：机器从「特定的」大量数据中总结规律，形成某些「特定的知识」，然后将这种「知识」应用到现实场景中去解决实际问题。</p>\n<p>人工智能可分三个级别：</p>\n<ol>\n<li><strong>弱人工智能</strong>：限定领域解决特定问题。</li>\n<li><strong>强人工智能</strong>：通用领域胜任人类所有工作。</li>\n<li><strong>超人工智能</strong>：远超人类智慧。</li>\n</ol>\n<p>我们现在还处在弱人工智能阶段，强人工智能还远没有实现，而超人工智能更是连影子都看不到。</p>\n<h2 id=\"机器学习\"><a href=\"#机器学习\" class=\"headerlink\" title=\"机器学习\"></a>机器学习</h2><p><strong>机器学习（Machine Learning）是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。</strong> 机器学习是人工智能的核心，是使计算机具有智能的根本途径，最基本的做法是使用算法解析数据、从中学习，然后对真实世界中的事件作出决策或预测。</p>\n<h2 id=\"机器学习分类\"><a href=\"#机器学习分类\" class=\"headerlink\" title=\"机器学习分类\"></a>机器学习分类</h2><p>按模型训练方式分：</p>\n<ul>\n<li>监督学习（Supervised Learning）</li>\n<li>无监督学习（Unsupervised Learning）</li>\n<li>半监督学习（Semi-supervised Learning）</li>\n<li>强化学习（Reinforcement Learning）</li>\n</ul>\n<h3 id=\"监督学习\"><a href=\"#监督学习\" class=\"headerlink\" title=\"监督学习\"></a>监督学习</h3><p>监督学习（Supervised Learning）是从有标记的训练数据中推导出预测函数，需要有明确的目标，清楚自己想要什么结果。简言之：<strong>给定数据，预测标签。</strong></p>\n<p>监督并不是人站在机器旁边看机器做的对不对，而是下面的流程：</p>\n<ol>\n<li>选择合适的模型</li>\n<li>把已知的“问题和答案”（训练集）提供给机器去学习</li>\n<li>机器总结出自己的“方法论”</li>\n<li>把“新的问题”（测试集）提供给机器去解答</li>\n</ol>\n<p>监督学习的特点：</p>\n<ul>\n<li>目标明确</li>\n<li>需要带标签的训练数据</li>\n<li>效果容易评估</li>\n</ul>\n<p>监督学习主要任务：</p>\n<ul>\n<li><strong>回归</strong>：预测连续的、具体的数值</li>\n<li><strong>分类</strong>：对各种事物分类，用于离散型预测</li>\n</ul>\n<h3 id=\"无监督学习\"><a href=\"#无监督学习\" class=\"headerlink\" title=\"无监督学习\"></a>无监督学习</h3><p>无监督学习（Unsupervised Learning）本质上是一种统计手段，在没有标签的数据里发现潜在的一些结构的训练方法。简言之：<strong>给定数据，寻找隐藏的结构。</strong></p>\n<p>无监督学习的特点：</p>\n<ul>\n<li>没有明确的目的</li>\n<li>不需要给数据打标签</li>\n<li>无法量化效果</li>\n</ul>\n<p>无监督学习应用场景：</p>\n<ul>\n<li>发现异常数据</li>\n<li>细分用户</li>\n<li>给用户做推荐</li>\n</ul>\n<p>无监督学习主要任务:</p>\n<ul>\n<li><strong>聚类</strong>：简单说就是一种自动分类的方法，在监督学习中，你很清楚每一个分类是什么，但是聚类则不是，你并去清楚聚类后的每个分类代表什么意思。</li>\n<li><strong>降维</strong>：感觉像是压缩，是为了在尽可能保存相关的结构的同时降低数据的复杂度。</li>\n</ul>\n<h3 id=\"半监督学习\"><a href=\"#半监督学习\" class=\"headerlink\" title=\"半监督学习\"></a>半监督学习</h3><p>半监督学习（Semi-supervised Learning）属于无监督学习和监督学习之间，使用标记和未标记的数据来执行有监督学习或者无监督学习任务。</p>\n<h3 id=\"强化学习\"><a href=\"#强化学习\" class=\"headerlink\" title=\"强化学习\"></a>强化学习</h3><p>强化学习（Reinforcement Learning）主要基于决策进行训练，根据输出结果（决策）的成功或失败来训练算法，通过大量经验训练优化后的算法将能够给出较好的预测。简言之：<strong>给定数据，学习如何选择一系列行动，以最大化长期收益。</strong></p>\n<p>强化学习特点：</p>\n<ul>\n<li>决策流程</li>\n<li>激励系统</li>\n<li>学习一系列的行动</li>\n</ul>\n<p>强化学习主要任务：</p>\n<ul>\n<li><strong>科学决策</strong>：优化决策以得到最佳结果。</li>\n<li><strong>动态规划</strong>：把复杂问题分解成若干个子问题，通过寻找子问提的最优解来得到复杂问题的最优解。</li>\n</ul>\n<h2 id=\"机器学习任务\"><a href=\"#机器学习任务\" class=\"headerlink\" title=\"机器学习任务\"></a>机器学习任务</h2><p>最常见的机器学习任务有三种：</p>\n<ul>\n<li>回归（Regression）</li>\n<li>分类（Classification）</li>\n<li>聚类（Clustering）</li>\n</ul>\n<h3 id=\"回归\"><a href=\"#回归\" class=\"headerlink\" title=\"回归\"></a>回归</h3><p>回归算法是一种对数值型连续随机变量进行预测和建模的监督学习方法。使用案例包括房价预测、股票走势或测试成绩等连续变化的案例。</p>\n<p>回归任务的特点是标注的数据集具有数值型的目标变量。也就是说，每一个观察样本都有一个数值型的标注真值以监督算法。</p>\n<h4 id=\"线性回归\"><a href=\"#线性回归\" class=\"headerlink\" title=\"线性回归\"></a>线性回归</h4><p>线性回归（Linear Regression）是处理回归任务最常用的算法之一。该算法的形式十分简单，它期望使用一个超平面拟合数据集（只有两个变量的时候就是一条直线）。如果数据集中的变量存在线性关系，那么其就能拟合地非常好。</p>\n<p><img src=\"/2020/08/13/Machine-Learning/linear-regression.png\" alt=\"linear-gression\"></p>\n<p>线性回归算法的建模过程就是使用数据点来寻找最佳拟合线。线性回归分为两种类型，即 <strong>简单线性回归（Simple Linear Regression）</strong>，只有一个自变量；和 <strong>多变量回归（Multiple Regression）</strong>，至少两组以上自变量。</p>\n<ul>\n<li>优点：线性回归的理解与解释都十分直观，并且还能通过正则化来降低过拟合的风险。另外，线性模型很容易使用随机梯度下降和新数据更新模型权重。</li>\n<li>线性回归在变量是非线性关系的时候表现很差。并且其也不够灵活以捕捉更复杂的模式，添加正确的交互项或使用多项式很困难并需要大量时间。</li>\n</ul>\n<h4 id=\"回归树\"><a href=\"#回归树\" class=\"headerlink\" title=\"回归树\"></a>回归树</h4><p>回归树（Regression Tree）（回归决策树，决策树的一种）通过将数据集重复分割为不同的分支而实现分层学习，分割的标准是最大化每一次分离的信息增益。这种分支结构让回归树很自然地学习到非线性关系。</p>\n<p><img src=\"/2020/08/13/Machine-Learning/regression-tree.png\" alt=\"regression-tree\"></p>\n<p>单一的回归树往往是不够用的，可以利用集成学习中的boosting框架对回归树进行改良升级，如 <strong>梯度提升树（Gradient Boost Decision Tree）</strong> 就是集成了许多独立训练的树。这种算法的主要思想就是组合多个弱学习算法而成为一种强学习算法。</p>\n<ul>\n<li><p>优点：决策树能学习非线性关系，对异常值也具有很强的鲁棒性。集成学习在实践中表现非常好，其经常赢得许多经典的（非深度学习）机器学习竞赛。</p>\n</li>\n<li><p>缺点：无约束的，单棵树很容易过拟合，因为单棵树可以保留分支（不剪枝），并直到其记住了训练数据。集成方法可以削弱这一缺点的影响。</p>\n</li>\n</ul>\n<h4 id=\"深度学习\"><a href=\"#深度学习\" class=\"headerlink\" title=\"深度学习\"></a>深度学习</h4><p>深度学习（Deep Learning）是指能学习极其复杂模式的多层神经网络。该算法使用在输入层和输出层之间的隐藏层对数据的中间表征建模，这也是其他算法很难学到的部分。</p>\n<p><img src=\"/2020/08/13/Machine-Learning/deep-learning-regression.png\" alt=\"deep-learning\"></p>\n<p>深度学习还有其他几个重要的机制，如卷积和 drop-out 等，这些机制令该算法能有效地学习到高维数据。然而深度学习相对于其他算法需要更多的数据，因为其有更大数量级的参数需要估计。</p>\n<ul>\n<li><p>优点：深度学习是目前某些领域最先进的技术，如计算机视觉和语音识别等。深度神经网络在图像、音频和文本等数据上表现优异，并且该算法也很容易对新数据使用反向传播算法更新模型参数。它们的架构（即层级的数量和结构）能够适应于多种问题，并且隐藏层也减少了算法对特征工程的依赖。</p>\n</li>\n<li><p>缺点：深度学习算法通常不适合作为通用目的的算法，因为其需要大量的数据。实际上，深度学习通常在经典机器学习问题上并没有集成方法表现得好。另外，其在训练上是计算密集型的，所以这就需要更富经验的人进行调参（即设置架构和超参数）以减少训练时间。</p>\n</li>\n</ul>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><p>分类方法是一种对离散型随机变量建模或预测的监督学习算法。使用案例包括邮件过滤、金融欺诈和预测雇员异动等输出为类别的任务。</p>\n<p>许多回归算法都有与其相对应的分类算法，分类算法通常适用于预测一个类别（或类别的概率）而不是连续的数值。</p>\n<h4 id=\"分类树\"><a href=\"#分类树\" class=\"headerlink\" title=\"分类树\"></a>分类树</h4><p>分类树（Classification Tree）（分类决策树，和回归树对应也是决策树的一种）。<br>相应的，<strong>随机森林（Random Forest）</strong> 是分类树的一种集成形式。</p>\n<p><img src=\"/2020/08/13/Machine-Learning/random-forest.png\" alt=\"random-forest\"></p>\n<ul>\n<li><p>优点：同回归方法一样，分类树的集成方法在实践中同样表现十分优良。它们通常对异常数据具有相当的鲁棒性和可扩展性。因为它的层级结构，分类树的集成方法能很自然地对非线性决策边界建模。</p>\n</li>\n<li><p>缺点：不可约束，单棵树趋向于过拟合，使用集成方法可以削弱这一方面的影响。</p>\n</li>\n</ul>\n<h4 id=\"逻辑回归\"><a href=\"#逻辑回归\" class=\"headerlink\" title=\"逻辑回归\"></a>逻辑回归</h4><p>逻辑回归（Logistic Regression）是与线性回归相对应的一种分类方法，一般用于需要明确输出的场景，如某些事件的发生（预测是否会发生降雨）。通常，逻辑回归使用某种函数将概率值压缩到某一特定范围。逻辑回归通过逻辑函数（即Sigmoid函数）将预测映射到0到1中间，因此预测值就可以看成某个类别的概率。</p>\n<p><img src=\"/2020/08/13/Machine-Learning/logistic-regression.png\" alt=\"logistic-regression\"></p>\n<p>该模型仍然还是「线性」的，所以只有在数据是线性可分（即数据可被一个超平面完全分离）时，算法才能有优秀的表现。同样 Logistic 模型能惩罚模型系数而进行正则化。</p>\n<ul>\n<li><p>优点：输出有很好的概率解释，并且算法也能正则化而避免过拟合。Logistic 模型很容易使用随机梯度下降和新数据更新模型权重。</p>\n</li>\n<li><p>缺点：Logistic 回归在多条或非线性决策边界时性能比较差。</p>\n</li>\n</ul>\n<h4 id=\"k-最近邻算法\"><a href=\"#k-最近邻算法\" class=\"headerlink\" title=\"k-最近邻算法\"></a>k-最近邻算法</h4><p>k-最近邻算法（k-Nearest Neighbor, KNN）是一种基本分类和回归方法，即给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的k个实例，这k个实例的多数属于某个类，就把该输入实例分到这个类中。用最近的邻居（k）来预测未知数据点。k值是预测精度的一个关键因素，无论是分类还是回归，衡量邻居的权重都非常有用，较近邻居的权重比较远邻居的权重大。</p>\n<p><img src=\"/2020/08/13/Machine-Learning/KNN.png\" alt=\"KNN\"></p>\n<p>用KNN算法给新输入的实例分类，只要找到离它最近的k个实例，看哪个类别多即可。而k值的选取，既不能太小，也不能太大，需要实验调整参数确定。</p>\n<ul>\n<li>优点：简单好用，容易理解，精度高，可用于数值型和离散型数据。</li>\n<li>缺点：对数据的局部结构非常敏感，计算量大，需要对数据进行规范化处理，使每个数据点都在相同的范围。</li>\n</ul>\n<h4 id=\"支持向量机\"><a href=\"#支持向量机\" class=\"headerlink\" title=\"支持向量机\"></a>支持向量机</h4><p>支持向量机（Support Vector Machine, SVM）可以使用一个称之为核函数的技巧扩展到非线性分类问题，而该算法本质上就是计算两个称之为支持向量的观测数据之间的距离。SVM 算法寻找的决策边界即最大化其与样本间隔的边界，因此支持向量机又称为大间距分类器。需要注意的是，支持向量机需要对输入数据进行完全标记，仅直接适用于两类任务，应用到多类任务时需要将其减少到几个二元问题。</p>\n<p><img src=\"/2020/08/13/Machine-Learning/svm.png\" alt=\"svm\"></p>\n<p>SVM使用线性核函数就能得到类似于logistic回归的结果，只不过支持向量机因为最大化了间隔而更具鲁棒性。因此，在实践中，SVM最大的优点就是可以使用非线性核函数对非线性决策边界建模。</p>\n<ul>\n<li>优点：SVM 能对非线性决策边界建模，并且有许多可选的核函数形式。SVM同样面对过拟合有相当大的鲁棒性，这一点在高维空间中尤其突出。</li>\n<li>缺点：然而，SVM是内存密集型算法，由于选择正确的核函数是很重要的，所以其很难调参，也不能扩展到较大的数据集中。目前在工业界中，随机森林通常优于支持向量机算法。</li>\n</ul>\n<h4 id=\"朴素贝叶斯\"><a href=\"#朴素贝叶斯\" class=\"headerlink\" title=\"朴素贝叶斯\"></a>朴素贝叶斯</h4><p>朴素贝叶斯（Naive Bayes）是一种基于贝叶斯定理和特征条件独立假设的分类方法。本质上朴素贝叶斯模型就是一个概率表，其通过训练数据更新这张表中的概率。为了预测一个新的观察值，朴素贝叶斯算法就是根据样本的特征值在概率表中寻找最大概率的那个类别。之所以称之为「朴素」，是因为该算法的核心就是特征条件独立性假设（每一个特征之间相互独立），而这一假设在现实世界中基本是不现实的。</p>\n<p>$P(y|x_1,…,x_n)=\\frac{P(y)\\prod(^n_{i=1}P(x_i|y)))}{P(x_1,…,x_n)}$</p>\n<ul>\n<li>优点：即使条件独立性假设很难成立，但朴素贝叶斯算法在实践中表现出乎意料地好。该算法很容易实现并能随数据集的更新而扩展。</li>\n<li>缺点：因为朴素贝叶斯算法太简单了，所以其也经常被以上列出的分类算法所替代。</li>\n</ul>\n<h4 id=\"深度学习-1\"><a href=\"#深度学习-1\" class=\"headerlink\" title=\"深度学习\"></a>深度学习</h4><p>深度学习（Deep Learning）同样很容易适应于分类问题。实际上，深度学习应用更多的是分类任务，如图像分类等。</p>\n<ul>\n<li>优点：深度学习非常适用于分类音频、文本和图像数据。<br>*缺点：和回归问题一样，深度神经网络需要大量的数据进行训练，所以其也不是一个通用目的的算法。</li>\n</ul>\n<h3 id=\"聚类\"><a href=\"#聚类\" class=\"headerlink\" title=\"聚类\"></a>聚类</h3><p>聚类是一种无监督学习任务，该算法基于数据的内部结构寻找观察样本的自然族群（即集群）。使用案例包括细分客户、新闻聚类、文章推荐等。</p>\n<p>因为聚类是一种无监督学习（即数据没有标注），并且通常使用数据可视化评价结果。如果存在「正确的回答」（即在训练集中存在预标注的集群），那么分类算法可能更加合适。</p>\n<h4 id=\"k均值聚类\"><a href=\"#k均值聚类\" class=\"headerlink\" title=\"k均值聚类\"></a>k均值聚类</h4><p>k均值聚类（K-Means Clustering）是一种通用目的的算法，聚类的度量基于样本点之间的几何距离（即在坐标平面中的距离）。集群是围绕在聚类中心的族群，而集群呈现出类球状并具有相似的大小。</p>\n<p><img src=\"/2020/08/13/Machine-Learning/k-means.png\" alt=\"k-mans\"></p>\n<p>K-Means算法把n个点（可以是样本的一次观察或一个实例）划分到k个集群（cluster），使得每个点都属于离他最近的均值（即聚类中心，centroid）对应的集群。重复上述过程一直持续到重心不改变。</p>\n<ul>\n<li>优点：K 均值聚类是最流行的聚类算法，因为该算法足够快速、简单，并且如果你的预处理数据和特征工程十分有效，那么该聚类算法将拥有令人惊叹的灵活性。</li>\n<li>缺点：该算法需要指定集群的数量，而 K 值的选择通常都不是那么容易确定的。另外，如果训练数据中的真实集群并不是类球状的，那么 K 均值聚类会得出一些比较差的集群。</li>\n</ul>\n<h4 id=\"层次聚类\"><a href=\"#层次聚类\" class=\"headerlink\" title=\"层次聚类\"></a>层次聚类</h4><p>层次聚类（Hierarchical Clustering）通过计算不同类别数据点之间的相似度来创建一棵有层次的嵌套聚类树，在聚类树中，不同类别的原始数据点是树的最底层，树的顶层是一个聚类的根节点。创建聚类树有自下而上合并和自上而下分裂两种方法，常见的是合并方法。</p>\n<p><img src=\"/2020/08/13/Machine-Learning/HC.png\" alt=\"HC\"></p>\n<p>层次聚类的合并算法是通过计算每一个类别的数据点与所有数据点之间的距离来确定它们之间的相似性，距离越小，相似度越高。并将距离最近的两个数据点或类别进行组合，生成聚类树。</p>\n<ul>\n<li>优点：层次聚类最主要的优点是集群不再需要假设为类球形。另外其也可以扩展到大数据集。</li>\n<li>缺点：有点像k均值聚类，该算法需要设定集群的数量（即在算法完成后需要保留的层次）。</li>\n</ul>\n<h2 id=\"神经网络\"><a href=\"#神经网络\" class=\"headerlink\" title=\"神经网络\"></a>神经网络</h2><p>神经网络（Neural Networks)是人工智能领域机器学习一部分，就好像人体的神经元、神经系统一样，人工智能的神经网络就是由一个个神经元搭建的系统，多层的神经网络就叫做深度神经网络（Deep Neural Network, <strong>DNN</strong>），也就是深度学习。它是机器学习最重要的一个分支，也是最流行一种的机器学习算法！</p>\n<p>DNN已经演变成许多不同的网络拓扑结构，比如，卷积神经网络（Convolutional Neural Networks, <strong>CNN</strong>）、循环神经网络（Recurrent Neural Networks, <strong>RNN</strong>）、长短期记忆（Long Short Term Memory, <strong>LSTM</strong>）、生成敌对网络（Generativ Adversarial Networks, <strong>GAN</strong>）等。</p>\n<hr>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://easyai.tech/ai-definition/ai/\">人工智能相关知识</a></li>\n<li><a href=\"https://www.jiqizhixin.com/articles/2017-05-20-3\">回归、分类与聚类</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/33794257\">Machine Learning:十大机器学习算法</a></li>\n<li><a href=\"https://towardsdatascience.com/understanding-neural-networks-from-neuron-to-rnn-cnn-and-deep-learning-cd88e90e0a90\">Understanding Neutral Networks</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>人工智能（Artificial Intelligence）、机器学习（Machine Learning）、深度学习（Deep Learning）、神经网络（Neutral Network）等等这些专业术语在平时学习和工作中经常出现，但有时感觉似懂非懂，傻傻分不清楚，所以决定在此简单的总结一下。</p>","more":"<p><img src=\"/2020/08/13/Machine-Learning/AI.png\" alt=\"AI\"></p>\n<p>从上图可以看出，<strong>人工智能、机器学习、神经网络、深度学习之间是包含关系</strong>，「人工智能」是最大的圈，它包括「机器学习」（机器根据数据“自学”）和「非机器学习」（机器从人直接获取指令）。「神经网络」是「机器学习」的一部分，它是由一个个「神经元」搭建的系统，多层的「神经网络」就叫做「深度学习」。</p>\n<h2 id=\"人工智能\"><a href=\"#人工智能\" class=\"headerlink\" title=\"人工智能\"></a>人工智能</h2><p><strong>人工智能（Artificial Intelligence）是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门技术科学。</strong> 简单地说，就是给机器赋予人的智能。其基本原理：机器从「特定的」大量数据中总结规律，形成某些「特定的知识」，然后将这种「知识」应用到现实场景中去解决实际问题。</p>\n<p>人工智能可分三个级别：</p>\n<ol>\n<li><strong>弱人工智能</strong>：限定领域解决特定问题。</li>\n<li><strong>强人工智能</strong>：通用领域胜任人类所有工作。</li>\n<li><strong>超人工智能</strong>：远超人类智慧。</li>\n</ol>\n<p>我们现在还处在弱人工智能阶段，强人工智能还远没有实现，而超人工智能更是连影子都看不到。</p>\n<h2 id=\"机器学习\"><a href=\"#机器学习\" class=\"headerlink\" title=\"机器学习\"></a>机器学习</h2><p><strong>机器学习（Machine Learning）是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。</strong> 机器学习是人工智能的核心，是使计算机具有智能的根本途径，最基本的做法是使用算法解析数据、从中学习，然后对真实世界中的事件作出决策或预测。</p>\n<h2 id=\"机器学习分类\"><a href=\"#机器学习分类\" class=\"headerlink\" title=\"机器学习分类\"></a>机器学习分类</h2><p>按模型训练方式分：</p>\n<ul>\n<li>监督学习（Supervised Learning）</li>\n<li>无监督学习（Unsupervised Learning）</li>\n<li>半监督学习（Semi-supervised Learning）</li>\n<li>强化学习（Reinforcement Learning）</li>\n</ul>\n<h3 id=\"监督学习\"><a href=\"#监督学习\" class=\"headerlink\" title=\"监督学习\"></a>监督学习</h3><p>监督学习（Supervised Learning）是从有标记的训练数据中推导出预测函数，需要有明确的目标，清楚自己想要什么结果。简言之：<strong>给定数据，预测标签。</strong></p>\n<p>监督并不是人站在机器旁边看机器做的对不对，而是下面的流程：</p>\n<ol>\n<li>选择合适的模型</li>\n<li>把已知的“问题和答案”（训练集）提供给机器去学习</li>\n<li>机器总结出自己的“方法论”</li>\n<li>把“新的问题”（测试集）提供给机器去解答</li>\n</ol>\n<p>监督学习的特点：</p>\n<ul>\n<li>目标明确</li>\n<li>需要带标签的训练数据</li>\n<li>效果容易评估</li>\n</ul>\n<p>监督学习主要任务：</p>\n<ul>\n<li><strong>回归</strong>：预测连续的、具体的数值</li>\n<li><strong>分类</strong>：对各种事物分类，用于离散型预测</li>\n</ul>\n<h3 id=\"无监督学习\"><a href=\"#无监督学习\" class=\"headerlink\" title=\"无监督学习\"></a>无监督学习</h3><p>无监督学习（Unsupervised Learning）本质上是一种统计手段，在没有标签的数据里发现潜在的一些结构的训练方法。简言之：<strong>给定数据，寻找隐藏的结构。</strong></p>\n<p>无监督学习的特点：</p>\n<ul>\n<li>没有明确的目的</li>\n<li>不需要给数据打标签</li>\n<li>无法量化效果</li>\n</ul>\n<p>无监督学习应用场景：</p>\n<ul>\n<li>发现异常数据</li>\n<li>细分用户</li>\n<li>给用户做推荐</li>\n</ul>\n<p>无监督学习主要任务:</p>\n<ul>\n<li><strong>聚类</strong>：简单说就是一种自动分类的方法，在监督学习中，你很清楚每一个分类是什么，但是聚类则不是，你并去清楚聚类后的每个分类代表什么意思。</li>\n<li><strong>降维</strong>：感觉像是压缩，是为了在尽可能保存相关的结构的同时降低数据的复杂度。</li>\n</ul>\n<h3 id=\"半监督学习\"><a href=\"#半监督学习\" class=\"headerlink\" title=\"半监督学习\"></a>半监督学习</h3><p>半监督学习（Semi-supervised Learning）属于无监督学习和监督学习之间，使用标记和未标记的数据来执行有监督学习或者无监督学习任务。</p>\n<h3 id=\"强化学习\"><a href=\"#强化学习\" class=\"headerlink\" title=\"强化学习\"></a>强化学习</h3><p>强化学习（Reinforcement Learning）主要基于决策进行训练，根据输出结果（决策）的成功或失败来训练算法，通过大量经验训练优化后的算法将能够给出较好的预测。简言之：<strong>给定数据，学习如何选择一系列行动，以最大化长期收益。</strong></p>\n<p>强化学习特点：</p>\n<ul>\n<li>决策流程</li>\n<li>激励系统</li>\n<li>学习一系列的行动</li>\n</ul>\n<p>强化学习主要任务：</p>\n<ul>\n<li><strong>科学决策</strong>：优化决策以得到最佳结果。</li>\n<li><strong>动态规划</strong>：把复杂问题分解成若干个子问题，通过寻找子问提的最优解来得到复杂问题的最优解。</li>\n</ul>\n<h2 id=\"机器学习任务\"><a href=\"#机器学习任务\" class=\"headerlink\" title=\"机器学习任务\"></a>机器学习任务</h2><p>最常见的机器学习任务有三种：</p>\n<ul>\n<li>回归（Regression）</li>\n<li>分类（Classification）</li>\n<li>聚类（Clustering）</li>\n</ul>\n<h3 id=\"回归\"><a href=\"#回归\" class=\"headerlink\" title=\"回归\"></a>回归</h3><p>回归算法是一种对数值型连续随机变量进行预测和建模的监督学习方法。使用案例包括房价预测、股票走势或测试成绩等连续变化的案例。</p>\n<p>回归任务的特点是标注的数据集具有数值型的目标变量。也就是说，每一个观察样本都有一个数值型的标注真值以监督算法。</p>\n<h4 id=\"线性回归\"><a href=\"#线性回归\" class=\"headerlink\" title=\"线性回归\"></a>线性回归</h4><p>线性回归（Linear Regression）是处理回归任务最常用的算法之一。该算法的形式十分简单，它期望使用一个超平面拟合数据集（只有两个变量的时候就是一条直线）。如果数据集中的变量存在线性关系，那么其就能拟合地非常好。</p>\n<p><img src=\"/2020/08/13/Machine-Learning/linear-regression.png\" alt=\"linear-gression\"></p>\n<p>线性回归算法的建模过程就是使用数据点来寻找最佳拟合线。线性回归分为两种类型，即 <strong>简单线性回归（Simple Linear Regression）</strong>，只有一个自变量；和 <strong>多变量回归（Multiple Regression）</strong>，至少两组以上自变量。</p>\n<ul>\n<li>优点：线性回归的理解与解释都十分直观，并且还能通过正则化来降低过拟合的风险。另外，线性模型很容易使用随机梯度下降和新数据更新模型权重。</li>\n<li>线性回归在变量是非线性关系的时候表现很差。并且其也不够灵活以捕捉更复杂的模式，添加正确的交互项或使用多项式很困难并需要大量时间。</li>\n</ul>\n<h4 id=\"回归树\"><a href=\"#回归树\" class=\"headerlink\" title=\"回归树\"></a>回归树</h4><p>回归树（Regression Tree）（回归决策树，决策树的一种）通过将数据集重复分割为不同的分支而实现分层学习，分割的标准是最大化每一次分离的信息增益。这种分支结构让回归树很自然地学习到非线性关系。</p>\n<p><img src=\"/2020/08/13/Machine-Learning/regression-tree.png\" alt=\"regression-tree\"></p>\n<p>单一的回归树往往是不够用的，可以利用集成学习中的boosting框架对回归树进行改良升级，如 <strong>梯度提升树（Gradient Boost Decision Tree）</strong> 就是集成了许多独立训练的树。这种算法的主要思想就是组合多个弱学习算法而成为一种强学习算法。</p>\n<ul>\n<li><p>优点：决策树能学习非线性关系，对异常值也具有很强的鲁棒性。集成学习在实践中表现非常好，其经常赢得许多经典的（非深度学习）机器学习竞赛。</p>\n</li>\n<li><p>缺点：无约束的，单棵树很容易过拟合，因为单棵树可以保留分支（不剪枝），并直到其记住了训练数据。集成方法可以削弱这一缺点的影响。</p>\n</li>\n</ul>\n<h4 id=\"深度学习\"><a href=\"#深度学习\" class=\"headerlink\" title=\"深度学习\"></a>深度学习</h4><p>深度学习（Deep Learning）是指能学习极其复杂模式的多层神经网络。该算法使用在输入层和输出层之间的隐藏层对数据的中间表征建模，这也是其他算法很难学到的部分。</p>\n<p><img src=\"/2020/08/13/Machine-Learning/deep-learning-regression.png\" alt=\"deep-learning\"></p>\n<p>深度学习还有其他几个重要的机制，如卷积和 drop-out 等，这些机制令该算法能有效地学习到高维数据。然而深度学习相对于其他算法需要更多的数据，因为其有更大数量级的参数需要估计。</p>\n<ul>\n<li><p>优点：深度学习是目前某些领域最先进的技术，如计算机视觉和语音识别等。深度神经网络在图像、音频和文本等数据上表现优异，并且该算法也很容易对新数据使用反向传播算法更新模型参数。它们的架构（即层级的数量和结构）能够适应于多种问题，并且隐藏层也减少了算法对特征工程的依赖。</p>\n</li>\n<li><p>缺点：深度学习算法通常不适合作为通用目的的算法，因为其需要大量的数据。实际上，深度学习通常在经典机器学习问题上并没有集成方法表现得好。另外，其在训练上是计算密集型的，所以这就需要更富经验的人进行调参（即设置架构和超参数）以减少训练时间。</p>\n</li>\n</ul>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><p>分类方法是一种对离散型随机变量建模或预测的监督学习算法。使用案例包括邮件过滤、金融欺诈和预测雇员异动等输出为类别的任务。</p>\n<p>许多回归算法都有与其相对应的分类算法，分类算法通常适用于预测一个类别（或类别的概率）而不是连续的数值。</p>\n<h4 id=\"分类树\"><a href=\"#分类树\" class=\"headerlink\" title=\"分类树\"></a>分类树</h4><p>分类树（Classification Tree）（分类决策树，和回归树对应也是决策树的一种）。<br>相应的，<strong>随机森林（Random Forest）</strong> 是分类树的一种集成形式。</p>\n<p><img src=\"/2020/08/13/Machine-Learning/random-forest.png\" alt=\"random-forest\"></p>\n<ul>\n<li><p>优点：同回归方法一样，分类树的集成方法在实践中同样表现十分优良。它们通常对异常数据具有相当的鲁棒性和可扩展性。因为它的层级结构，分类树的集成方法能很自然地对非线性决策边界建模。</p>\n</li>\n<li><p>缺点：不可约束，单棵树趋向于过拟合，使用集成方法可以削弱这一方面的影响。</p>\n</li>\n</ul>\n<h4 id=\"逻辑回归\"><a href=\"#逻辑回归\" class=\"headerlink\" title=\"逻辑回归\"></a>逻辑回归</h4><p>逻辑回归（Logistic Regression）是与线性回归相对应的一种分类方法，一般用于需要明确输出的场景，如某些事件的发生（预测是否会发生降雨）。通常，逻辑回归使用某种函数将概率值压缩到某一特定范围。逻辑回归通过逻辑函数（即Sigmoid函数）将预测映射到0到1中间，因此预测值就可以看成某个类别的概率。</p>\n<p><img src=\"/2020/08/13/Machine-Learning/logistic-regression.png\" alt=\"logistic-regression\"></p>\n<p>该模型仍然还是「线性」的，所以只有在数据是线性可分（即数据可被一个超平面完全分离）时，算法才能有优秀的表现。同样 Logistic 模型能惩罚模型系数而进行正则化。</p>\n<ul>\n<li><p>优点：输出有很好的概率解释，并且算法也能正则化而避免过拟合。Logistic 模型很容易使用随机梯度下降和新数据更新模型权重。</p>\n</li>\n<li><p>缺点：Logistic 回归在多条或非线性决策边界时性能比较差。</p>\n</li>\n</ul>\n<h4 id=\"k-最近邻算法\"><a href=\"#k-最近邻算法\" class=\"headerlink\" title=\"k-最近邻算法\"></a>k-最近邻算法</h4><p>k-最近邻算法（k-Nearest Neighbor, KNN）是一种基本分类和回归方法，即给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的k个实例，这k个实例的多数属于某个类，就把该输入实例分到这个类中。用最近的邻居（k）来预测未知数据点。k值是预测精度的一个关键因素，无论是分类还是回归，衡量邻居的权重都非常有用，较近邻居的权重比较远邻居的权重大。</p>\n<p><img src=\"/2020/08/13/Machine-Learning/KNN.png\" alt=\"KNN\"></p>\n<p>用KNN算法给新输入的实例分类，只要找到离它最近的k个实例，看哪个类别多即可。而k值的选取，既不能太小，也不能太大，需要实验调整参数确定。</p>\n<ul>\n<li>优点：简单好用，容易理解，精度高，可用于数值型和离散型数据。</li>\n<li>缺点：对数据的局部结构非常敏感，计算量大，需要对数据进行规范化处理，使每个数据点都在相同的范围。</li>\n</ul>\n<h4 id=\"支持向量机\"><a href=\"#支持向量机\" class=\"headerlink\" title=\"支持向量机\"></a>支持向量机</h4><p>支持向量机（Support Vector Machine, SVM）可以使用一个称之为核函数的技巧扩展到非线性分类问题，而该算法本质上就是计算两个称之为支持向量的观测数据之间的距离。SVM 算法寻找的决策边界即最大化其与样本间隔的边界，因此支持向量机又称为大间距分类器。需要注意的是，支持向量机需要对输入数据进行完全标记，仅直接适用于两类任务，应用到多类任务时需要将其减少到几个二元问题。</p>\n<p><img src=\"/2020/08/13/Machine-Learning/svm.png\" alt=\"svm\"></p>\n<p>SVM使用线性核函数就能得到类似于logistic回归的结果，只不过支持向量机因为最大化了间隔而更具鲁棒性。因此，在实践中，SVM最大的优点就是可以使用非线性核函数对非线性决策边界建模。</p>\n<ul>\n<li>优点：SVM 能对非线性决策边界建模，并且有许多可选的核函数形式。SVM同样面对过拟合有相当大的鲁棒性，这一点在高维空间中尤其突出。</li>\n<li>缺点：然而，SVM是内存密集型算法，由于选择正确的核函数是很重要的，所以其很难调参，也不能扩展到较大的数据集中。目前在工业界中，随机森林通常优于支持向量机算法。</li>\n</ul>\n<h4 id=\"朴素贝叶斯\"><a href=\"#朴素贝叶斯\" class=\"headerlink\" title=\"朴素贝叶斯\"></a>朴素贝叶斯</h4><p>朴素贝叶斯（Naive Bayes）是一种基于贝叶斯定理和特征条件独立假设的分类方法。本质上朴素贝叶斯模型就是一个概率表，其通过训练数据更新这张表中的概率。为了预测一个新的观察值，朴素贝叶斯算法就是根据样本的特征值在概率表中寻找最大概率的那个类别。之所以称之为「朴素」，是因为该算法的核心就是特征条件独立性假设（每一个特征之间相互独立），而这一假设在现实世界中基本是不现实的。</p>\n<p>$P(y|x_1,…,x_n)=\\frac{P(y)\\prod(^n_{i=1}P(x_i|y)))}{P(x_1,…,x_n)}$</p>\n<ul>\n<li>优点：即使条件独立性假设很难成立，但朴素贝叶斯算法在实践中表现出乎意料地好。该算法很容易实现并能随数据集的更新而扩展。</li>\n<li>缺点：因为朴素贝叶斯算法太简单了，所以其也经常被以上列出的分类算法所替代。</li>\n</ul>\n<h4 id=\"深度学习-1\"><a href=\"#深度学习-1\" class=\"headerlink\" title=\"深度学习\"></a>深度学习</h4><p>深度学习（Deep Learning）同样很容易适应于分类问题。实际上，深度学习应用更多的是分类任务，如图像分类等。</p>\n<ul>\n<li>优点：深度学习非常适用于分类音频、文本和图像数据。<br>*缺点：和回归问题一样，深度神经网络需要大量的数据进行训练，所以其也不是一个通用目的的算法。</li>\n</ul>\n<h3 id=\"聚类\"><a href=\"#聚类\" class=\"headerlink\" title=\"聚类\"></a>聚类</h3><p>聚类是一种无监督学习任务，该算法基于数据的内部结构寻找观察样本的自然族群（即集群）。使用案例包括细分客户、新闻聚类、文章推荐等。</p>\n<p>因为聚类是一种无监督学习（即数据没有标注），并且通常使用数据可视化评价结果。如果存在「正确的回答」（即在训练集中存在预标注的集群），那么分类算法可能更加合适。</p>\n<h4 id=\"k均值聚类\"><a href=\"#k均值聚类\" class=\"headerlink\" title=\"k均值聚类\"></a>k均值聚类</h4><p>k均值聚类（K-Means Clustering）是一种通用目的的算法，聚类的度量基于样本点之间的几何距离（即在坐标平面中的距离）。集群是围绕在聚类中心的族群，而集群呈现出类球状并具有相似的大小。</p>\n<p><img src=\"/2020/08/13/Machine-Learning/k-means.png\" alt=\"k-mans\"></p>\n<p>K-Means算法把n个点（可以是样本的一次观察或一个实例）划分到k个集群（cluster），使得每个点都属于离他最近的均值（即聚类中心，centroid）对应的集群。重复上述过程一直持续到重心不改变。</p>\n<ul>\n<li>优点：K 均值聚类是最流行的聚类算法，因为该算法足够快速、简单，并且如果你的预处理数据和特征工程十分有效，那么该聚类算法将拥有令人惊叹的灵活性。</li>\n<li>缺点：该算法需要指定集群的数量，而 K 值的选择通常都不是那么容易确定的。另外，如果训练数据中的真实集群并不是类球状的，那么 K 均值聚类会得出一些比较差的集群。</li>\n</ul>\n<h4 id=\"层次聚类\"><a href=\"#层次聚类\" class=\"headerlink\" title=\"层次聚类\"></a>层次聚类</h4><p>层次聚类（Hierarchical Clustering）通过计算不同类别数据点之间的相似度来创建一棵有层次的嵌套聚类树，在聚类树中，不同类别的原始数据点是树的最底层，树的顶层是一个聚类的根节点。创建聚类树有自下而上合并和自上而下分裂两种方法，常见的是合并方法。</p>\n<p><img src=\"/2020/08/13/Machine-Learning/HC.png\" alt=\"HC\"></p>\n<p>层次聚类的合并算法是通过计算每一个类别的数据点与所有数据点之间的距离来确定它们之间的相似性，距离越小，相似度越高。并将距离最近的两个数据点或类别进行组合，生成聚类树。</p>\n<ul>\n<li>优点：层次聚类最主要的优点是集群不再需要假设为类球形。另外其也可以扩展到大数据集。</li>\n<li>缺点：有点像k均值聚类，该算法需要设定集群的数量（即在算法完成后需要保留的层次）。</li>\n</ul>\n<h2 id=\"神经网络\"><a href=\"#神经网络\" class=\"headerlink\" title=\"神经网络\"></a>神经网络</h2><p>神经网络（Neural Networks)是人工智能领域机器学习一部分，就好像人体的神经元、神经系统一样，人工智能的神经网络就是由一个个神经元搭建的系统，多层的神经网络就叫做深度神经网络（Deep Neural Network, <strong>DNN</strong>），也就是深度学习。它是机器学习最重要的一个分支，也是最流行一种的机器学习算法！</p>\n<p>DNN已经演变成许多不同的网络拓扑结构，比如，卷积神经网络（Convolutional Neural Networks, <strong>CNN</strong>）、循环神经网络（Recurrent Neural Networks, <strong>RNN</strong>）、长短期记忆（Long Short Term Memory, <strong>LSTM</strong>）、生成敌对网络（Generativ Adversarial Networks, <strong>GAN</strong>）等。</p>\n<hr>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://easyai.tech/ai-definition/ai/\">人工智能相关知识</a></li>\n<li><a href=\"https://www.jiqizhixin.com/articles/2017-05-20-3\">回归、分类与聚类</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/33794257\">Machine Learning:十大机器学习算法</a></li>\n<li><a href=\"https://towardsdatascience.com/understanding-neural-networks-from-neuron-to-rnn-cnn-and-deep-learning-cd88e90e0a90\">Understanding Neutral Networks</a></li>\n</ol>"}],"PostAsset":[{"_id":"source/_posts/git-vs-svn/git_process.jpg","post":"ckdypyf6t0001m4k23iqy0ytj","slug":"git_process.jpg","modified":1,"renderable":1},{"_id":"source/_posts/git-vs-svn/svn_process.jpg","post":"ckdypyf6t0001m4k23iqy0ytj","slug":"svn_process.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Machine-Learning/AI.png","post":"ckdypyf72000em4k20t25cdnx","slug":"AI.png","modified":1,"renderable":1},{"_id":"source/_posts/Machine-Learning/deep-learning-regression.png","post":"ckdypyf72000em4k20t25cdnx","slug":"deep-learning-regression.png","modified":1,"renderable":1},{"_id":"source/_posts/Machine-Learning/HC.png","post":"ckdypyf72000em4k20t25cdnx","slug":"HC.png","modified":1,"renderable":1},{"_id":"source/_posts/Machine-Learning/k-means.png","post":"ckdypyf72000em4k20t25cdnx","slug":"k-means.png","modified":1,"renderable":1},{"_id":"source/_posts/Machine-Learning/KNN.png","post":"ckdypyf72000em4k20t25cdnx","slug":"KNN.png","modified":1,"renderable":1},{"_id":"source/_posts/Machine-Learning/linear-regression.png","post":"ckdypyf72000em4k20t25cdnx","slug":"linear-regression.png","modified":1,"renderable":1},{"_id":"source/_posts/Machine-Learning/logistic-regression.png","post":"ckdypyf72000em4k20t25cdnx","slug":"logistic-regression.png","modified":1,"renderable":1},{"_id":"source/_posts/Machine-Learning/random-forest.png","post":"ckdypyf72000em4k20t25cdnx","slug":"random-forest.png","modified":1,"renderable":1},{"_id":"source/_posts/Machine-Learning/regression-tree.png","post":"ckdypyf72000em4k20t25cdnx","slug":"regression-tree.png","modified":1,"renderable":1},{"_id":"source/_posts/Machine-Learning/svm.png","post":"ckdypyf72000em4k20t25cdnx","slug":"svm.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"ckdypyf6t0001m4k23iqy0ytj","category_id":"ckdypyf6x0003m4k27okw1nz0","_id":"ckdypyf6y0006m4k20ghk1ngz"},{"post_id":"ckdypyf70000am4k2581p9ohp","category_id":"ckdypyf6x0003m4k27okw1nz0","_id":"ckdypyf73000gm4k2d68q527m"},{"post_id":"ckdypyf71000dm4k2hoi5da99","category_id":"ckdypyf6x0003m4k27okw1nz0","_id":"ckdypyf74000lm4k212o9ccyv"},{"post_id":"ckdypyf70000bm4k209gqfmqz","category_id":"ckdypyf72000fm4k247ju0a1r","_id":"ckdypyf75000om4k2cinf5a0q"},{"post_id":"ckdypyf72000em4k20t25cdnx","category_id":"ckdypyf74000jm4k25rwnaa7o","_id":"ckdypyf75000sm4k2f2op7xnl"}],"PostTag":[{"post_id":"ckdypyf6t0001m4k23iqy0ytj","tag_id":"ckdypyf6w0002m4k2ei7939j4","_id":"ckdypyf6y0007m4k20e6vh47i"},{"post_id":"ckdypyf6t0001m4k23iqy0ytj","tag_id":"ckdypyf6x0004m4k2dthq93go","_id":"ckdypyf6y0008m4k2boh3hnp8"},{"post_id":"ckdypyf6t0001m4k23iqy0ytj","tag_id":"ckdypyf6y0005m4k298ngcxua","_id":"ckdypyf6y0009m4k2h7qlhcrd"},{"post_id":"ckdypyf70000am4k2581p9ohp","tag_id":"ckdypyf6w0002m4k2ei7939j4","_id":"ckdypyf74000im4k2bjf4fhp1"},{"post_id":"ckdypyf70000am4k2581p9ohp","tag_id":"ckdypyf71000cm4k24319el5z","_id":"ckdypyf74000km4k2gtyvac4m"},{"post_id":"ckdypyf70000bm4k209gqfmqz","tag_id":"ckdypyf71000cm4k24319el5z","_id":"ckdypyf75000nm4k2chisd2g1"},{"post_id":"ckdypyf71000dm4k2hoi5da99","tag_id":"ckdypyf6x0004m4k2dthq93go","_id":"ckdypyf75000qm4k2fs40cznd"},{"post_id":"ckdypyf71000dm4k2hoi5da99","tag_id":"ckdypyf71000cm4k24319el5z","_id":"ckdypyf75000rm4k2gi42dj68"},{"post_id":"ckdypyf72000em4k20t25cdnx","tag_id":"ckdypyf75000pm4k27lyj306u","_id":"ckdypyf75000tm4k20m64fn82"},{"post_id":"ckdypyf72000em4k20t25cdnx","tag_id":"ckdypyf6y0005m4k298ngcxua","_id":"ckdypyf76000um4k24h4i4c8k"}],"Tag":[{"name":"git","_id":"ckdypyf6w0002m4k2ei7939j4"},{"name":"svn","_id":"ckdypyf6x0004m4k2dthq93go"},{"name":"introduction","_id":"ckdypyf6y0005m4k298ngcxua"},{"name":"tutorial","_id":"ckdypyf71000cm4k24319el5z"},{"name":"machine Learning","_id":"ckdypyf75000pm4k27lyj306u"}]}}